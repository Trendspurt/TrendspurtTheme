!function(e){var t={};function n(l){if(t[l])return t[l].exports;var c=t[l]={i:l,l:!1,exports:{}};return e[l].call(c.exports,c,c.exports,n),c.l=!0,c.exports}n.m=e,n.c=t,n.d=function(e,t,l){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:l})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var l=Object.create(null);if(n.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var c in e)n.d(l,c,function(t){return e[t]}.bind(null,c));return l},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=12)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\n/* harmony import */ var _libs_nanoevents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar LOG = \'[ FxBase ]\';\nvar DEBUG = true;\n\nvar _default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  _inherits(_default, _NanoEvents);\n\n  function _default(element, options) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).call(this));\n    _this.manifest = _this.constructor.manifest;\n    _this.element = element;\n    _this.options = options || {};\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.options = Object.assign({}, this.manifest.options, this.options);\n      this.init();\n    }\n  }, {\n    key: "update",\n    value: function update() {}\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(_libs_nanoevents__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L0Z4QmFzZS5qcz8wZDlmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgTmFub0V2ZW50cyBmcm9tICcuLi8uLi8uLi9saWJzL25hbm9ldmVudHMnO1xudmFyIExPRyA9ICdbIEZ4QmFzZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX05hbm9FdmVudHMpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfTmFub0V2ZW50cyk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMubWFuaWZlc3QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5tYW5pZmVzdDtcbiAgICBfdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWFuaWZlc3Qub3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge31cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KE5hbm9FdmVudHMpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  SCENE_PLUGINS_READY: 'SCENE_PLUGINS_READY',\n  SCENE_PRE_READY: 'SCENE_PRE_READY',\n  SCENE_READY: 'SCENE_READY'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9mdXNpb24vQ29uc3QuanM/YTE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gIFNDRU5FX1BMVUdJTlNfUkVBRFk6ICdTQ0VORV9QTFVHSU5TX1JFQURZJyxcbiAgU0NFTkVfUFJFX1JFQURZOiAnU0NFTkVfUFJFX1JFQURZJyxcbiAgU0NFTkVfUkVBRFk6ICdTQ0VORV9SRUFEWSdcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Nano Events\n * Taken from https://github.com/ai/nanoevents (MIT license)\n */\nvar _default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    _defineProperty(this, "events", {});\n  }\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {string} event The event name.\n   * @param {...*} arguments The arguments for listeners.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * ee.emit(\'tick\', tickType, tickDuration)\n   *\n   * @alias NanoEvents#emit\n   * @method\n   */\n\n\n  _createClass(_default, [{\n    key: "emit",\n    value: function emit(event) {\n      var args = [].slice.call(arguments, 1) // Array.prototype.call() returns empty array if context is not array-like\n      ;\n      [].slice.call(this.events[event] || []).filter(function (i) {\n        i.apply(null, args);\n      });\n    }\n    /**\n     * Add a listener for a given event.\n     *\n     * @param {string} event The event name.\n     * @param {function} cb The listener function.\n     *\n     * @return {function} Unbind listener from event.\n     *\n     * @example\n     * const unbind = ee.on(\'tick\', (tickType, tickDuration) => {\n     *   count += 1\n     * })\n     *\n     * disable () {\n     *   unbind()\n     * }\n     *\n     * @alias NanoEvents#on\n     * @method\n     */\n\n  }, {\n    key: "on",\n    value: function on(event, cb) {\n      if (false) {}\n\n      (this.events[event] = this.events[event] || []).push(cb);\n      return function () {\n        this.events[event] = this.events[event].filter(function (i) {\n          return i !== cb;\n        });\n      }.bind(this);\n    }\n    /**\n     * Removes all listeners.\n     *\n     * @returns {undefined}\n     *\n     * @example\n     * unbindAll(emitter)\n     */\n\n  }, {\n    key: "unbindAll",\n    value: function unbindAll() {\n      this.events = {};\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbmFub2V2ZW50cy5qcz9kYTNiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBOYW5vIEV2ZW50c1xuICogVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWkvbmFub2V2ZW50cyAoTUlUIGxpY2Vuc2UpXG4gKi9cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge30pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cyBUaGUgYXJndW1lbnRzIGZvciBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWUuZW1pdCgndGljaycsIHRpY2tUeXBlLCB0aWNrRHVyYXRpb24pXG4gICAqXG4gICAqIEBhbGlhcyBOYW5vRXZlbnRzI2VtaXRcbiAgICogQG1ldGhvZFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSAvLyBBcnJheS5wcm90b3R5cGUuY2FsbCgpIHJldHVybnMgZW1wdHkgYXJyYXkgaWYgY29udGV4dCBpcyBub3QgYXJyYXktbGlrZVxuICAgICAgO1xuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICBpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBVbmJpbmQgbGlzdGVuZXIgZnJvbSBldmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdW5iaW5kID0gZWUub24oJ3RpY2snLCAodGlja1R5cGUsIHRpY2tEdXJhdGlvbikgPT4ge1xuICAgICAqICAgY291bnQgKz0gMVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBkaXNhYmxlICgpIHtcbiAgICAgKiAgIHVuYmluZCgpXG4gICAgICogfVxuICAgICAqXG4gICAgICogQGFsaWFzIE5hbm9FdmVudHMjb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICAodGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGNiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gY2I7XG4gICAgICAgIH0pO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB1bmJpbmRBbGwoZW1pdHRlcilcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval("var content = __webpack_require__(4);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(6)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0eWxlL2Z1c2lvbi5zY3NzPzhiZWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9mdXNpb24uc2Nzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(5)(false);\n// Module\nexports.push([module.i, ".fusion--player{display:flex;justify-content:center}.fusion--player .fusion--viewport{position:relative;width:100%;height:100%}.fusion--player .fusion--viewport .fusion--scene{position:absolute;top:0;right:0;bottom:0;left:0;overflow-x:hidden;overflow-y:hidden;visibility:hidden;opacity:0}.fusion--player .fusion--viewport .fusion--scene.visible{visibility:visible;opacity:1}.fusion--player .fusion--viewport .fusion--scene.fusion--scene--iframe iframe.fusion--iframe{overflow:hidden;border:none}.fusion--player .fusion--viewport .fusion--scene .fusion--scene--content{position:absolute;top:0;right:0;bottom:0;left:0;transform-origin:top left;overflow:hidden}.fusion--player .fusion--viewport .fusion--scene .fusion--scene--content>*{position:absolute;width:100%;height:100%}.fusion--player .fusion--viewport .fusion--scene .fusion--scene--content>*>*{position:absolute;top:0;left:0}.fusion--player .fusion--viewport .fusion--scene--debugger--guidesWrapper{position:absolute;top:0;right:0;bottom:0;left:0;z-index:9999999;pointer-events:none}.fusion--player .fusion--viewport .fusion--scene--debugger--guidesWrapper .guide-horizontal-center{position:absolute;top:0;bottom:0;left:50%;width:1px;z-index:99999;border-left:1px dashed rgba(0,0,0,0.8)}.fusion--player .fusion--viewport .fusion--scene--debugger--guidesWrapper .guide-sceneBounds{position:absolute;top:0;right:0;bottom:0;left:0;transform-origin:top left;background-color:rgba(108,159,255,0.3)}\\n", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0eWxlL2Z1c2lvbi5zY3NzPzk4MWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZnVzaW9uLS1wbGF5ZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmZ1c2lvbi0tcGxheWVyIC5mdXNpb24tLXZpZXdwb3J0e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmZ1c2lvbi0tcGxheWVyIC5mdXNpb24tLXZpZXdwb3J0IC5mdXNpb24tLXNjZW5le3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6aGlkZGVuO3Zpc2liaWxpdHk6aGlkZGVuO29wYWNpdHk6MH0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUudmlzaWJsZXt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eToxfS5mdXNpb24tLXBsYXllciAuZnVzaW9uLS12aWV3cG9ydCAuZnVzaW9uLS1zY2VuZS5mdXNpb24tLXNjZW5lLS1pZnJhbWUgaWZyYW1lLmZ1c2lvbi0taWZyYW1le292ZXJmbG93OmhpZGRlbjtib3JkZXI6bm9uZX0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUgLmZ1c2lvbi0tc2NlbmUtLWNvbnRlbnR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7dHJhbnNmb3JtLW9yaWdpbjp0b3AgbGVmdDtvdmVyZmxvdzpoaWRkZW59LmZ1c2lvbi0tcGxheWVyIC5mdXNpb24tLXZpZXdwb3J0IC5mdXNpb24tLXNjZW5lIC5mdXNpb24tLXNjZW5lLS1jb250ZW50Pip7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUgLmZ1c2lvbi0tc2NlbmUtLWNvbnRlbnQ+Kj4qe3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MH0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUtLWRlYnVnZ2VyLS1ndWlkZXNXcmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO3otaW5kZXg6OTk5OTk5OTtwb2ludGVyLWV2ZW50czpub25lfS5mdXNpb24tLXBsYXllciAuZnVzaW9uLS12aWV3cG9ydCAuZnVzaW9uLS1zY2VuZS0tZGVidWdnZXItLWd1aWRlc1dyYXBwZXIgLmd1aWRlLWhvcml6b250YWwtY2VudGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO2xlZnQ6NTAlO3dpZHRoOjFweDt6LWluZGV4Ojk5OTk5O2JvcmRlci1sZWZ0OjFweCBkYXNoZWQgcmdiYSgwLDAsMCwwLjgpfS5mdXNpb24tLXBsYXllciAuZnVzaW9uLS12aWV3cG9ydCAuZnVzaW9uLS1zY2VuZS0tZGVidWdnZXItLWd1aWRlc1dyYXBwZXIgLmd1aWRlLXNjZW5lQm91bmRze3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDEwOCwxNTksMjU1LDAuMyl9XFxuXCIsIFwiXCJdKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIntcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gbW9kdWxlc1tfaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG4gICAgICAvLyB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG4gICAgICAvLyBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cbiAgICAgIGlmIChpdGVtWzBdID09IG51bGwgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiKFwiLmNvbmNhdChpdGVtWzJdLCBcIikgYW5kIChcIikuY29uY2F0KG1lZGlhUXVlcnksIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290KS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZXMgPSBbXTtcbiAgdmFyIG5ld1N0eWxlcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY3NzID0gaXRlbVsxXTtcbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdO1xuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH07XG5cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcGFydHM6IFtwYXJ0XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrKztcblxuICAgICAgZm9yICg7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHJlZnM6IDEsXG4gICAgICAgIHBhcnRzOiBwYXJ0c1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuYXR0cmlidXRlcyA6IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG4gICAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgICAgZG9tU3R5bGUucmVmcy0tO1xuICAgICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICBhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtYXlSZW1vdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2RvbVN0eWxlID0gbWF5UmVtb3ZlW19pXTtcblxuICAgICAgaWYgKF9kb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2RvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgX2RvbVN0eWxlLnBhcnRzW2pdKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bX2RvbVN0eWxlLmlkXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module){eval('module.exports = JSON.parse("{\\"name\\":\\"mojo\\",\\"version\\":\\"0.9.0\\",\\"description\\":\\"\\",\\"private\\":true,\\"scripts\\":{\\"build\\":\\"npx webpack --mode production\\",\\"serve\\":\\"http-server -g -c-1\\"},\\"author\\":\\"Simon Widjaja\\",\\"devDependencies\\":{\\"@babel/cli\\":\\"^7.7.0\\",\\"@babel/core\\":\\"^7.7.2\\",\\"@babel/node\\":\\"^7.7.0\\",\\"@babel/plugin-proposal-class-properties\\":\\"^7.7.0\\",\\"@babel/preset-env\\":\\"^7.7.1\\",\\"@babel/register\\":\\"^7.7.0\\",\\"babel-register\\":\\"^6.26.0\\",\\"webpack\\":\\"^4.41.2\\",\\"webpack-cli\\":\\"^3.3.11\\",\\"webpack-dev-server\\":\\"^3.9.0\\"},\\"dependencies\\":{\\"@babel/plugin-transform-async-to-generator\\":\\"^7.7.0\\",\\"babel-loader\\":\\"^8.0.6\\",\\"core-js\\":\\"^3.4.0\\",\\"css-loader\\":\\"^3.2.0\\",\\"fs-extra\\":\\"^9.0.1\\",\\"lodash.debounce\\":\\"^4.0.8\\",\\"lodash.throttle\\":\\"^4.1.1\\",\\"node-sass\\":\\"^4.13.1\\",\\"regenerator-runtime\\":\\"^0.13.3\\",\\"sass-loader\\":\\"^8.0.0\\",\\"style-loader\\":\\"^1.0.0\\"}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanM/ODRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzP2Y3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\n/* harmony import */ var _FxBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// SCAN FOR FX\n\nvar LOG = \'[ FxScanner ]\';\nvar DEBUG = true;\n\nvar _default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n  }\n\n  _createClass(_default, null, [{\n    key: "scan",\n    value: function scan(context) {\n      if (context instanceof Element) {\n        this._scanElement(context);\n      }\n    }\n  }, {\n    key: "_scanElement",\n    value: function _scanElement(element) {\n      var _this = this;\n\n      Object.keys(mojo.fx).forEach(function (item) {\n        if (mojo.fx[item].prototype instanceof _FxBase__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]) {\n          _this._processFx(element, item);\n        }\n      });\n    }\n  }, {\n    key: "_processFx",\n    value: function _processFx(element, fx) {\n      var attr = "mojo-fx-".concat(mojo.fx[fx].manifest.id);\n      var elements = element.querySelectorAll("[".concat(attr, "]"));\n\n      for (var i = 0; i < elements.length; i++) {\n        var _element = elements[i];\n        if (_element.mojo && _element.mojo.scanned[fx]) continue;\n        var options = this.extractOptions(_element.getAttribute(attr));\n        var trigger = options.trigger || mojo.fx[fx].manifest.options.trigger || \'click\';\n        DEBUG && console.log(LOG, \'_processFx()\', "fx: ".concat(fx));\n        mojo.add(_element, trigger, mojo.fx[fx], options);\n        mojo.prepareElement(_element); // element.mojo.scanned = true;\n\n        _element.mojo.scanned[fx] = true;\n      }\n    }\n  }, {\n    key: "extractOptions",\n    value: function extractOptions(raw) {\n      if (!raw) return {}; // Eval solution\n\n      return eval("(function() { return ".concat(raw, "})()")); // Primitive version (only support flat non-nested values, no arrays , no objects)\n      // raw = raw.replace(/{(.*)}/, \'$1\');\n      // let args = raw.split(\',\').map( (item) => item.trim().split(\':\') );\n      // let result = {};\n      // args.forEach(item => { \n      //   let val = item[1].trim();\n      //   if (!isNaN(val)) { val = +val; }\n      //   else if (val.indexOf("\'") == 0) { val = val.replace(/\'/g, \'\'); }\n      //   else if (val == \'true\') { val = true; }\n      //   else if (val == \'false\') { val = false; }\n      //   result[item[0].trim()] = val; \n      // });\n      // return result;\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9GeFNjYW5uZXIuanM/MDI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIFNDQU4gRk9SIEZYXG5pbXBvcnQgRnhCYXNlIGZyb20gJy4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGeFNjYW5uZXIgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBudWxsLCBbe1xuICAgIGtleTogXCJzY2FuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYW4oY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3NjYW5FbGVtZW50KGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2NhbkVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NjYW5FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKG1vam8uZngpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKG1vam8uZnhbaXRlbV0ucHJvdG90eXBlIGluc3RhbmNlb2YgRnhCYXNlKSB7XG4gICAgICAgICAgX3RoaXMuX3Byb2Nlc3NGeChlbGVtZW50LCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzRnhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NGeChlbGVtZW50LCBmeCkge1xuICAgICAgdmFyIGF0dHIgPSBcIm1vam8tZngtXCIuY29uY2F0KG1vam8uZnhbZnhdLm1hbmlmZXN0LmlkKTtcbiAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoYXR0ciwgXCJdXCIpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2VsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgaWYgKF9lbGVtZW50Lm1vam8gJiYgX2VsZW1lbnQubW9qby5zY2FubmVkW2Z4XSkgY29udGludWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5leHRyYWN0T3B0aW9ucyhfZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgICB2YXIgdHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlciB8fCBtb2pvLmZ4W2Z4XS5tYW5pZmVzdC5vcHRpb25zLnRyaWdnZXIgfHwgJ2NsaWNrJztcbiAgICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnX3Byb2Nlc3NGeCgpJywgXCJmeDogXCIuY29uY2F0KGZ4KSk7XG4gICAgICAgIG1vam8uYWRkKF9lbGVtZW50LCB0cmlnZ2VyLCBtb2pvLmZ4W2Z4XSwgb3B0aW9ucyk7XG4gICAgICAgIG1vam8ucHJlcGFyZUVsZW1lbnQoX2VsZW1lbnQpOyAvLyBlbGVtZW50Lm1vam8uc2Nhbm5lZCA9IHRydWU7XG5cbiAgICAgICAgX2VsZW1lbnQubW9qby5zY2FubmVkW2Z4XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RPcHRpb25zKHJhdykge1xuICAgICAgaWYgKCFyYXcpIHJldHVybiB7fTsgLy8gRXZhbCBzb2x1dGlvblxuXG4gICAgICByZXR1cm4gZXZhbChcIihmdW5jdGlvbigpIHsgcmV0dXJuIFwiLmNvbmNhdChyYXcsIFwifSkoKVwiKSk7IC8vIFByaW1pdGl2ZSB2ZXJzaW9uIChvbmx5IHN1cHBvcnQgZmxhdCBub24tbmVzdGVkIHZhbHVlcywgbm8gYXJyYXlzICwgbm8gb2JqZWN0cylcbiAgICAgIC8vIHJhdyA9IHJhdy5yZXBsYWNlKC97KC4qKX0vLCAnJDEnKTtcbiAgICAgIC8vIGxldCBhcmdzID0gcmF3LnNwbGl0KCcsJykubWFwKCAoaXRlbSkgPT4gaXRlbS50cmltKCkuc3BsaXQoJzonKSApO1xuICAgICAgLy8gbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgLy8gYXJncy5mb3JFYWNoKGl0ZW0gPT4geyBcbiAgICAgIC8vICAgbGV0IHZhbCA9IGl0ZW1bMV0udHJpbSgpO1xuICAgICAgLy8gICBpZiAoIWlzTmFOKHZhbCkpIHsgdmFsID0gK3ZhbDsgfVxuICAgICAgLy8gICBlbHNlIGlmICh2YWwuaW5kZXhPZihcIidcIikgPT0gMCkgeyB2YWwgPSB2YWwucmVwbGFjZSgvJy9nLCAnJyk7IH1cbiAgICAgIC8vICAgZWxzZSBpZiAodmFsID09ICd0cnVlJykgeyB2YWwgPSB0cnVlOyB9XG4gICAgICAvLyAgIGVsc2UgaWYgKHZhbCA9PSAnZmFsc2UnKSB7IHZhbCA9IGZhbHNlOyB9XG4gICAgICAvLyAgIHJlc3VsdFtpdGVtWzBdLnRyaW0oKV0gPSB2YWw7IFxuICAgICAgLy8gfSk7XG4gICAgICAvLyByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/lodash.throttle/index.js\nvar lodash_throttle = __webpack_require__(9);\nvar lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);\n\n// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js\nvar lodash_debounce = __webpack_require__(10);\nvar lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);\n\n// CONCATENATED MODULE: ./src/mojo/core/Brain.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar LOG = \'[ Brain ]\';\nvar DEBUG = true;\n\nvar Brain_default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    DEBUG && console.log(LOG, \'constructor()\');\n  }\n\n  _createClass(_default, [{\n    key: "add",\n    value: function add(p) {\n      console.log(LOG, \'add() p:\', p);\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./src/mojo/fx/FxBase.js\nvar FxBase = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/mojo/core/Mojo.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction Mojo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Mojo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Mojo_createClass(Constructor, protoProps, staticProps) { if (protoProps) Mojo_defineProperties(Constructor.prototype, protoProps); if (staticProps) Mojo_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar Mojo_LOG = \'[ Mojo ]\';\nvar Mojo_DEBUG = true;\n\nvar Mojo_default =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor\n   */\n  function _default() {\n    Mojo_classCallCheck(this, _default);\n\n    _defineProperty(this, "brain", void 0);\n\n    this.brain = new Brain_default();\n    Mojo_DEBUG && console.log(Mojo_LOG, \'constructor()\');\n  }\n  /**\n   * Add\n   * For parameters also see addBehavior()\n   * @example\n   * \n   *  // Effect Behavior\n   *  mojo.add(el, \'click\', mojo.fx.Magnet, {delay: 100});\n   * \n   *  // Custom behavior\n   *  mojo.add(el, \'toggle\', {\n   *    start: () => {\n   *      console.log(\'START\');\n   *    },\n   *    end: () => {\n   *      console.log(\'END\');\n   *    }\n   *  });\n   */\n\n\n  Mojo_createClass(_default, [{\n    key: "add",\n    value: function add() {\n      // Delegate depending on signature\n      if (arguments[0] instanceof Element && (typeof arguments[1] === \'string\' || _typeof(arguments[1]) === \'object\' && typeof arguments[1].type === \'string\') && arguments[2].prototype instanceof mojo.fx.FxBase) {\n        this.addEffectBehavior.apply(this, arguments);\n      } else if (arguments[0] instanceof Element && (typeof arguments[1] === \'string\' || _typeof(arguments[1]) === \'object\' && typeof arguments[1].type === \'string\') && _typeof(arguments[2]) === \'object\') {\n        this.addBehavior.apply(this, arguments);\n      } else {\n        console.log(Mojo_LOG, \'add()\', \'unknown signature\');\n      }\n    }\n    /**\n     * Add Effect Behavior\n     * @param {HTMLElement} el The host element to add the behavior to\n     * @param {(string|object)} trigger The trigger type (e.g. click, hover, toggle etc.)\n     *                                  E.g. \'click\' or {type: \'hover\', area: \'#custom-trigger-area\'}\n     * @param {FxBase} Fx The effect class to apply (e.g. mojo.fx.Magnet)\n     * @param {object} [fxOptions] Optional effect options (e.g {speed: 2})\n     */\n\n  }, {\n    key: "addEffectBehavior",\n    value: function addEffectBehavior(el, trigger, Fx, fxOptions) {\n      //---\n      // Create fx\n      fxOptions = fxOptions ? fxOptions : {};\n      var fx = new Fx(el, fxOptions);\n      el = fx.element;\n      this.addBehavior(el, trigger, fx, fxOptions ? fxOptions.id : undefined);\n    }\n    /**\n     * Add behavior\n     * (supports automatic area detection: if next node has attribute "mojo-trigger-area" )\n     * @param {HTMLElement} el The host element to add the behavior to\n     * @param {(string|object)} trigger The trigger type (e.g. click, hover, toggle etc.)\n     *                                  E.g. \'click\' or {type: \'hover\', area: \'#custom-trigger-area\'}\n     * @param {Object} action Action object\n     * @param {Function} action.start Start function\n     * @param {Function} action.end End function\n     * @param {string} [id] Optional id\n     */\n\n  }, {\n    key: "addBehavior",\n    value: function addBehavior(el, trigger, action, id) {\n      Mojo_DEBUG && console.log(Mojo_LOG, \'addBehavior()\', el, trigger, action, id);\n      var triggerType = typeof trigger === \'string\' ? trigger : trigger.type,\n          standard = true,\n          startTrigger,\n          endTrigger; //---\n      // Area\n\n      var area = typeof trigger === \'string\' ? el : typeof trigger.area === \'string\' ? document.querySelector(trigger.area) : trigger.area;\n\n      if (area == el) {\n        // Auto detect area (next node has "mojo-trigger-area" attribute)\n        if (el.nextElementSibling && el.nextElementSibling.hasAttribute(\'mojo-trigger-area\')) {\n          if (el.nextElementSibling.tagName == \'svg\') {\n            area = el.nextElementSibling.firstChild;\n            el.nextElementSibling.style.pointerEvents = \'none\';\n          } else {\n            area = el.nextElementSibling;\n          }\n\n          el.style.pointerEvents = \'none\';\n        }\n      } //---\n      // Trigger type\n\n\n      switch (triggerType) {\n        case \'\':\n        case \'auto\':\n          standard = false;\n          break;\n\n        case \'click\':\n          startTrigger = \'click\';\n          break;\n\n        case \'hover\':\n          startTrigger = \'mouseenter\';\n          endTrigger = \'mouseleave\';\n          break;\n\n        case \'toggle\':\n          startTrigger = \'click\';\n          endTrigger = \'click\';\n          standard = false;\n          break;\n\n        default:\n          // e.g. mouseenter, mouseleave, blur, focus etc.\n          startTrigger = triggerType;\n      } //---\n      // Setup triggering (event listeners etc.)\n\n\n      if (standard) {\n        // startTrigger && area.addEventListener(startTrigger, startFunc);\n        // endTrigger && area.addEventListener(endTrigger, endFunc);\n        startTrigger && action.start && area.addEventListener(startTrigger, action.start.bind(action, el));\n        endTrigger && action.end && area.addEventListener(endTrigger, action.end.bind(action, el));\n      } else {\n        switch (triggerType) {\n          case \'\':\n          case \'auto\':\n            action.start();\n            break;\n\n          case \'toggle\':\n            var on = true;\n            area.addEventListener(\'click\', function (evt) {\n              on ? action.start(el) : action.end(el);\n              on = !on;\n            });\n            break;\n        }\n      } //---\n      // Memorize on element level if fx has id\n\n\n      if (id) {\n        Mojo_DEBUG && console.log(Mojo_LOG, \'addBehavior()\', \'Memorize on element with id:\', id);\n        this.prepareElement(el);\n        el.mojo.fx.push(action);\n      }\n    }\n    /**\n     * Prepare element\n     */\n\n  }, {\n    key: "prepareElement",\n    value: function prepareElement(el) {\n      !el.mojo && (el.mojo = {\n        fx: [],\n        scanned: {}\n      });\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./src/mojo/fx/FxScanner.js\nvar FxScanner = __webpack_require__(11);\n\n// CONCATENATED MODULE: ./src/mojo/fx/core/Glitch.js\nfunction Glitch_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Glitch_typeof = function _typeof(obj) { return typeof obj; }; } else { Glitch_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Glitch_typeof(obj); }\n\nfunction Glitch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Glitch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Glitch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Glitch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Glitch_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (Glitch_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction Glitch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Glitch_LOG = \'[ FX : Glitch ]\';\nvar Glitch_DEBUG = true;\n\nvar Glitch_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  _inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Glitch_classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).apply(this, arguments));\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "src", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "canvas", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "stage", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "width", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "height", void 0);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "dpr", !window.devicePixelRatio ? 1 : window.devicePixelRatio >= 2 ? 2 : 1);\n\n    Glitch_defineProperty(_assertThisInitialized(_this), "segments", []);\n\n    _get(_getPrototypeOf(_default.prototype), "init", _assertThisInitialized(_this)).call(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Glitch_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      // Save original image\n      this.original = this.element;\n      this.src = this.original.getAttribute(\'src\'); // Create canvas\n\n      var canvas = this.canvas = document.createElement(\'canvas\');\n      this.original.getAttribute(\'id\') && canvas.setAttribute(\'id\', this.original.getAttribute(\'id\'));\n      this.stage = new createjs.Stage(this.canvas);\n      this.original.parentNode.insertBefore(this.canvas, this.original.nextSibling);\n      this.original.style.opacity = 0;\n      this.original.style.pointerEvents = \'none\';\n      var computedStyle = window.getComputedStyle(this.original);\n      canvas.style.width = computedStyle.width;\n      canvas.style.height = computedStyle.height;\n      canvas.style.left = computedStyle.left;\n      canvas.style.top = computedStyle.top;\n      canvas.style.transform = computedStyle.transform; // canvas.style.pointerEvents = \'none\';\n\n      this.width = parseInt(computedStyle.width) * this.dpr;\n      this.height = parseInt(computedStyle.height) * this.dpr; // let rect = canvas.getBoundingClientRect();\n      // canvas.width = rect.width * this.dpr;\n      // canvas.height = rect.height * this.dpr;\n      // canvas.getContext(\'2d\').scale(this.dpr, this.dpr);\n\n      canvas.width = canvas.clientWidth * this.dpr;\n      canvas.height = canvas.clientHeight * this.dpr;\n      canvas.getContext(\'2d\').scale(this.dpr, this.dpr);\n      this.element = this.canvas; // this.original.parentNode.removeChild(this.original);\n      // this.original.remove();\n\n      this.original.removeAttribute(\'id\'); // Create segments\n\n      var seedIndex = 0,\n          top = 0;\n\n      while (true) {\n        var seed = Math.round(this.options.seed[seedIndex] * this.options.factor);\n        var image = new createjs.Bitmap(this.src);\n        var shape = new createjs.Shape();\n        shape.graphics.beginFill("#FFFFFF").drawRect(0, top, this.width, seed);\n        image.mask = shape;\n        this.stage.addChild(image);\n        this.segments.push(image); // End\n\n        if (top >= parseInt(computedStyle.height) * this.dpr) break; // Iterate \n\n        top += seed;\n        seedIndex = seedIndex >= this.options.seed.length - 1 ? 0 : ++seedIndex;\n      } // Timeline\n\n\n      this.timeline = gsap.timeline({\n        paused: true,\n        delay: this.options.delay / 1000,\n        repeat: this.options.repeat,\n        repeatDelay: this.options.repeatDelay / 1000,\n        yoyo: this.options.yoyo,\n        onUpdate: this.stage.update.bind(this.stage)\n      });\n      this.segments.forEach(function (segment, index) {\n        _this2.timeline.from(segment, {\n          x: (Math.random() - .5) * 20 * _this2.options.power,\n          alpha: 0,\n          duration: 0.5,\n          ease: _this2.options.easeing\n        }, "".concat(index * _this2.options.stagger / 1000));\n      });\n      this.timeline.timeScale(this.timeline.duration() / (this.options.duration / 1000));\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.timeline.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.timeline.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitch_defineProperty(Glitch_default, "manifest", {\n  id: \'glitch\',\n  options: {\n    trigger: \'hover\',\n    duration: 1000,\n    delay: 0,\n    repeat: 0,\n    repeatDelay: 1000,\n    yoyo: true,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 10,\n    power: 80,\n    stagger: 10,\n    easing: \'power4.inOut\' // back.out(3),\n\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/core/Magnet.js\nfunction Magnet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Magnet_typeof = function _typeof(obj) { return typeof obj; }; } else { Magnet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Magnet_typeof(obj); }\n\nfunction Magnet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Magnet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Magnet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Magnet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Magnet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Magnet_possibleConstructorReturn(self, call) { if (call && (Magnet_typeof(call) === "object" || typeof call === "function")) { return call; } return Magnet_assertThisInitialized(self); }\n\nfunction Magnet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Magnet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Magnet_setPrototypeOf(subClass, superClass); }\n\nfunction Magnet_setPrototypeOf(o, p) { Magnet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Magnet_setPrototypeOf(o, p); }\n\nfunction Magnet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Magnet_get = Reflect.get; } else { Magnet_get = function _get(target, property, receiver) { var base = Magnet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Magnet_get(target, property, receiver || target); }\n\nfunction Magnet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Magnet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Magnet_getPrototypeOf(o) { Magnet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Magnet_getPrototypeOf(o); }\n\nfunction Magnet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Magnet_LOG = \'[ FX : Magnet ]\';\nvar Magnet_DEBUG = false;\n\nvar Magnet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Magnet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Magnet_classCallCheck(this, _default);\n\n    _this = Magnet_possibleConstructorReturn(this, Magnet_getPrototypeOf(_default).apply(this, arguments));\n\n    Magnet_get(Magnet_getPrototypeOf(_default.prototype), "init", Magnet_assertThisInitialized(_this)).call(Magnet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Magnet_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      gsap.to(this.element, {\n        scale: this.options.scale,\n        transformOrigin: \'50% 50%\',\n        delay: this.options.delay / 1000,\n        duration: this.options.duration / 1000,\n        ease: \'power4.out(9)\'\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      gsap.isTweening(this.element) && gsap.killTweensOf(this.element, \'scale\');\n      gsap.to(this.element, {\n        scale: 1,\n        duration: this.options.duration / 1000,\n        ease: this.options.easeOut\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nMagnet_defineProperty(Magnet_default, "manifest", {\n  id: \'magnet\',\n  options: {\n    trigger: \'hover\',\n    delay: 0,\n    duration: 500,\n    scale: 1.2,\n    easeOut: \'back.out(3)\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/core/Hide.js\nfunction Hide_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Hide_typeof = function _typeof(obj) { return typeof obj; }; } else { Hide_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Hide_typeof(obj); }\n\nfunction Hide_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Hide_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Hide_createClass(Constructor, protoProps, staticProps) { if (protoProps) Hide_defineProperties(Constructor.prototype, protoProps); if (staticProps) Hide_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Hide_possibleConstructorReturn(self, call) { if (call && (Hide_typeof(call) === "object" || typeof call === "function")) { return call; } return Hide_assertThisInitialized(self); }\n\nfunction Hide_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Hide_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Hide_setPrototypeOf(subClass, superClass); }\n\nfunction Hide_setPrototypeOf(o, p) { Hide_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Hide_setPrototypeOf(o, p); }\n\nfunction Hide_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Hide_get = Reflect.get; } else { Hide_get = function _get(target, property, receiver) { var base = Hide_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Hide_get(target, property, receiver || target); }\n\nfunction Hide_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Hide_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Hide_getPrototypeOf(o) { Hide_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Hide_getPrototypeOf(o); }\n\nfunction Hide_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Hide_LOG = \'[ FX : Hide ]\';\nvar Hide_DEBUG = false;\n\nvar Hide_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Hide_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Hide_classCallCheck(this, _default);\n\n    _this = Hide_possibleConstructorReturn(this, Hide_getPrototypeOf(_default).apply(this, arguments));\n\n    Hide_get(Hide_getPrototypeOf(_default.prototype), "init", Hide_assertThisInitialized(_this)).call(Hide_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Hide_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      this.element.style.opacity = 0;\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nHide_defineProperty(Hide_default, "manifest", {\n  id: \'hide\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/anime/Magnet.js\nfunction anime_Magnet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { anime_Magnet_typeof = function _typeof(obj) { return typeof obj; }; } else { anime_Magnet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return anime_Magnet_typeof(obj); }\n\nfunction anime_Magnet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction anime_Magnet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction anime_Magnet_createClass(Constructor, protoProps, staticProps) { if (protoProps) anime_Magnet_defineProperties(Constructor.prototype, protoProps); if (staticProps) anime_Magnet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction anime_Magnet_possibleConstructorReturn(self, call) { if (call && (anime_Magnet_typeof(call) === "object" || typeof call === "function")) { return call; } return anime_Magnet_assertThisInitialized(self); }\n\nfunction anime_Magnet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction anime_Magnet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) anime_Magnet_setPrototypeOf(subClass, superClass); }\n\nfunction anime_Magnet_setPrototypeOf(o, p) { anime_Magnet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return anime_Magnet_setPrototypeOf(o, p); }\n\nfunction anime_Magnet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { anime_Magnet_get = Reflect.get; } else { anime_Magnet_get = function _get(target, property, receiver) { var base = anime_Magnet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return anime_Magnet_get(target, property, receiver || target); }\n\nfunction anime_Magnet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = anime_Magnet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction anime_Magnet_getPrototypeOf(o) { anime_Magnet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return anime_Magnet_getPrototypeOf(o); }\n\nfunction anime_Magnet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar anime_Magnet_LOG = \'[ FX : AnimateMagnet (Anime) ]\';\nvar anime_Magnet_DEBUG = true;\n\nvar anime_Magnet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  anime_Magnet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    anime_Magnet_classCallCheck(this, _default);\n\n    _this = anime_Magnet_possibleConstructorReturn(this, anime_Magnet_getPrototypeOf(_default).apply(this, arguments));\n\n    anime_Magnet_defineProperty(anime_Magnet_assertThisInitialized(_this), "an", void 0);\n\n    anime_Magnet_get(anime_Magnet_getPrototypeOf(_default.prototype), "init", anime_Magnet_assertThisInitialized(_this)).call(anime_Magnet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  anime_Magnet_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      this.cancelAnimation(this.an);\n      this.an = anime({\n        targets: this.element,\n        scale: this.options.scale,\n        duration: 600,\n        easing: \'easeOutExpo\'\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      // gsap.isTweening(this.element) && gsap.killTweensOf(this.element);\n      // gsap.to(this.element, {scale: 1, duration: 0.4, ease: this.options.easeOut});\n      // this.an.end.restart();\n      this.cancelAnimation(this.an);\n      this.an = anime({\n        targets: this.element,\n        scale: 1,\n        duration: 400,\n        easing: \'easeOutBack\'\n      });\n    }\n  }, {\n    key: "cancelAnimation",\n    value: function cancelAnimation(animation) {\n      animation && animation.pause(); // let activeInstances = anime.running;\n      // let index = activeInstances.indexOf(animation);\n      // activeInstances.splice(index, 1);\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nanime_Magnet_defineProperty(anime_Magnet_default, "manifest", {\n  id: \'Magnet\',\n  options: {\n    scale: 1.2,\n    easeOut: \'back.out(3)\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/TypeAnimation.js\nfunction TypeAnimation_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TypeAnimation_typeof = function _typeof(obj) { return typeof obj; }; } else { TypeAnimation_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TypeAnimation_typeof(obj); }\n\nfunction TypeAnimation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TypeAnimation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TypeAnimation_createClass(Constructor, protoProps, staticProps) { if (protoProps) TypeAnimation_defineProperties(Constructor.prototype, protoProps); if (staticProps) TypeAnimation_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TypeAnimation_possibleConstructorReturn(self, call) { if (call && (TypeAnimation_typeof(call) === "object" || typeof call === "function")) { return call; } return TypeAnimation_assertThisInitialized(self); }\n\nfunction TypeAnimation_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TypeAnimation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TypeAnimation_setPrototypeOf(subClass, superClass); }\n\nfunction TypeAnimation_setPrototypeOf(o, p) { TypeAnimation_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TypeAnimation_setPrototypeOf(o, p); }\n\nfunction TypeAnimation_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { TypeAnimation_get = Reflect.get; } else { TypeAnimation_get = function _get(target, property, receiver) { var base = TypeAnimation_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return TypeAnimation_get(target, property, receiver || target); }\n\nfunction TypeAnimation_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TypeAnimation_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TypeAnimation_getPrototypeOf(o) { TypeAnimation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TypeAnimation_getPrototypeOf(o); }\n\nfunction TypeAnimation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar TypeAnimation_LOG = \'[ FX : TypeAnimation ]\';\nvar TypeAnimation_DEBUG = true;\n\nvar TypeAnimation_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  TypeAnimation_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    TypeAnimation_classCallCheck(this, _default);\n\n    _this = TypeAnimation_possibleConstructorReturn(this, TypeAnimation_getPrototypeOf(_default).apply(this, arguments));\n\n    TypeAnimation_get(TypeAnimation_getPrototypeOf(_default.prototype), "init", TypeAnimation_assertThisInitialized(_this)).call(TypeAnimation_assertThisInitialized(_this));\n\n    TypeAnimation_get(TypeAnimation_getPrototypeOf(_default.prototype), "start", TypeAnimation_assertThisInitialized(_this)).call(TypeAnimation_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  TypeAnimation_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      TypeAnimation_DEBUG && console.log(TypeAnimation_LOG, \'init()\', this.options); // Prepare elements\n      // Wrap every letter in a span\n      // this.element.innerHTML = this.element.textContent.replace(/\\S/g, "<span class=\'letter\'>$&</span>");\n\n      this.element.innerHTML = this.element.textContent.replace(/[\\S\\W]/g, "<span class=\'letter\'>$&</span>").replace(/> </g, ">&nbsp;<");\n      gsap.set(this.element.querySelectorAll(\'.letter\'), {\n        display: \'inline-block\',\n        opacity: 0\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      TypeAnimation_DEBUG && console.log(TypeAnimation_LOG, \'start()\');\n      gsap.fromTo(this.element.querySelectorAll(\'.letter\'), {\n        scale: 2\n      }, {\n        opacity: 1,\n        scale: 1,\n        delay: this.options.delay,\n        duration: 0.2,\n        stagger: 1 / (this.options.speed / 2),\n        ease: \'back.out(3)\'\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nTypeAnimation_defineProperty(TypeAnimation_default, "manifest", {\n  id: \'type\',\n  options: {\n    trigger: \'auto\',\n    speed: 100,\n    delay: .5\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/Particles.js\nfunction Particles_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Particles_typeof = function _typeof(obj) { return typeof obj; }; } else { Particles_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Particles_typeof(obj); }\n\nfunction Particles_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Particles_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Particles_createClass(Constructor, protoProps, staticProps) { if (protoProps) Particles_defineProperties(Constructor.prototype, protoProps); if (staticProps) Particles_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Particles_possibleConstructorReturn(self, call) { if (call && (Particles_typeof(call) === "object" || typeof call === "function")) { return call; } return Particles_assertThisInitialized(self); }\n\nfunction Particles_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Particles_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Particles_setPrototypeOf(subClass, superClass); }\n\nfunction Particles_setPrototypeOf(o, p) { Particles_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Particles_setPrototypeOf(o, p); }\n\nfunction Particles_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Particles_get = Reflect.get; } else { Particles_get = function _get(target, property, receiver) { var base = Particles_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Particles_get(target, property, receiver || target); }\n\nfunction Particles_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Particles_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Particles_getPrototypeOf(o) { Particles_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Particles_getPrototypeOf(o); }\n\nfunction Particles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Particles_LOG = \'[ FX : Particles ]\';\nvar Particles_DEBUG = true;\n\nvar Particles_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Particles_inherits(_default, _FxBase);\n\n  // Effect center\n  function _default() {\n    var _this;\n\n    Particles_classCallCheck(this, _default);\n\n    _this = Particles_possibleConstructorReturn(this, Particles_getPrototypeOf(_default).apply(this, arguments));\n\n    Particles_defineProperty(Particles_assertThisInitialized(_this), "center", {\n      left: 0,\n      top: 0\n    });\n\n    Particles_get(Particles_getPrototypeOf(_default.prototype), "init", Particles_assertThisInitialized(_this)).call(Particles_assertThisInitialized(_this));\n\n    return _this;\n  } // TEMP: Use FusionHelper instead\n  // TEMP: Use FusionHelper instead\n\n\n  Particles_createClass(_default, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      Particles_DEBUG && console.log(Particles_LOG, \'init()\', this.options);\n      this.appendHtml(document.body, "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"82\\" height=\\"129\\" viewBox=\\"0 0 82 129\\" style=\\"display: none\\">\\n      <circle id=\\"tplCircle\\" cx=\\"9.5\\" cy=\\"9.5\\" r=\\"9.5\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n      <path id=\\"tplTriangle\\" d=\\"M9.5,0,19,17H0Z\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n      <rect id=\\"tplRect\\" width=\\"19\\" height=\\"19\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n    </svg>"); // Gather templates\n\n      this.templates = [{\n        node: document.getElementById(\'tplCircle\')\n      }, {\n        node: document.getElementById(\'tplTriangle\')\n      }, {\n        node: document.getElementById(\'tplRect\')\n      }]; // Cache width/height\n\n      this.templates.forEach(function (item) {\n        var rect = item.node.getBoundingClientRect();\n        item.width = rect.width;\n        item.height = rect.height;\n      });\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      Particles_DEBUG && console.log(Particles_LOG, \'update()\'); // let computedStyle = window.getComputedStyle(this.element);\n      // this.center = {\n      //   left: parseInt(computedStyle.left) + parseInt(computedStyle.width)/2,\n      //   top: parseInt(computedStyle.top) + parseInt(computedStyle.height)/2 \n      // };\n      // DEBUG && console.log(LOG, \'update() center:\', this.center);\n\n      function getLocalBoundingClientRect(el) {\n        var a = el.getBoundingClientRect();\n        var b = el.parentNode.getBoundingClientRect();\n        return {\n          left: a.left - b.left,\n          top: a.top - b.top,\n          width: a.width,\n          height: a.height\n        };\n      }\n\n      var rect = getLocalBoundingClientRect(this.element);\n      this.center = {\n        left: Math.round(rect.left + rect.width / 2),\n        top: Math.round(rect.top + rect.height / 2)\n      };\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Particles_DEBUG && console.log(Particles_LOG, \'start()\');\n      this.update();\n      var svg = this.appendHtml(this.element.parentElement, "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"1\\" height=\\"1\\" viewBox=\\"0 0 1 1\\" style=\\"pointer-events: none; position: absolute; overflow: visible;\\"></svg>");\n      svg.style.left = this.center.left + \'px\';\n      svg.style.top = this.center.top + \'px\'; // Generate\n\n      for (var i = 0; i < 5; i++) {\n        var tpl = this.templates[Math.ceil(Math.random() * this.templates.length) - 1];\n        var node = tpl.node.cloneNode();\n        node.setAttribute(\'id\', \'random-\' + Math.round(Math.random() * 10000000000));\n        node.style.display = \'block\';\n        node.style.opacity = 0; // node.style.transform = \'translate(\'+(originX-tpl.width/2)+\'px, \'+(originY-tpl.height/2)+\'px)\';\n\n        node.style.transform = \'translate(-10px, -10px)\';\n        svg.appendChild(node); //gsap.to(node, {duration: 0.2*i, opacity: 1, y: \'-=80\', rotation: 360, transformOrigin: "50% 50%"});\n\n        var tl = gsap.timeline({\n          delay: 0.05 * i\n        }); // tl.timeScale(0.1);\n\n        var x = i % 2 ? -40 * (Math.random() * 2 * this.options.power) : 40 * (Math.random() * 2 * this.options.power);\n        var y = -30 * (i / 2 + 1) * this.options.power;\n        tl.to(node, {\n          duration: 1.4,\n          ease: "power3.out",\n          x: x,\n          y: y,\n          rotation: 130,\n          scale: this.options.scale,\n          transformOrigin: "50% 50%"\n        }, 0);\n        tl.to(node, {\n          duration: 0.2,\n          opacity: 1\n        }, 0);\n        tl.to(node, {\n          duration: 0.3,\n          opacity: 0\n        }, "-=".concat(0.3 * this.options.decay));\n        tl.eventCallback("onComplete", function (node) {\n          var parentNode = node.parentNode;\n          parentNode.removeChild(node);\n\n          if (parentNode.children.length == 0) {\n            parentNode.parentNode.removeChild(parentNode);\n          }\n        }, [node]);\n      }\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nParticles_defineProperty(Particles_default, "manifest", {\n  id: \'Particles\',\n  options: {\n    trigger: \'click\',\n    scale: 2,\n    power: 2,\n    decay: 3\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/Spritesheet.js\nfunction Spritesheet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Spritesheet_typeof = function _typeof(obj) { return typeof obj; }; } else { Spritesheet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Spritesheet_typeof(obj); }\n\nfunction Spritesheet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Spritesheet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Spritesheet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Spritesheet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Spritesheet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Spritesheet_possibleConstructorReturn(self, call) { if (call && (Spritesheet_typeof(call) === "object" || typeof call === "function")) { return call; } return Spritesheet_assertThisInitialized(self); }\n\nfunction Spritesheet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Spritesheet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Spritesheet_setPrototypeOf(subClass, superClass); }\n\nfunction Spritesheet_setPrototypeOf(o, p) { Spritesheet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Spritesheet_setPrototypeOf(o, p); }\n\nfunction Spritesheet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Spritesheet_get = Reflect.get; } else { Spritesheet_get = function _get(target, property, receiver) { var base = Spritesheet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Spritesheet_get(target, property, receiver || target); }\n\nfunction Spritesheet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Spritesheet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Spritesheet_getPrototypeOf(o) { Spritesheet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Spritesheet_getPrototypeOf(o); }\n\nfunction Spritesheet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Spritesheet_LOG = \'[ FX : Spritesheet ]\';\nvar Spritesheet_DEBUG = false;\n\nvar Spritesheet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Spritesheet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Spritesheet_classCallCheck(this, _default);\n\n    _this = Spritesheet_possibleConstructorReturn(this, Spritesheet_getPrototypeOf(_default).apply(this, arguments));\n\n    Spritesheet_defineProperty(Spritesheet_assertThisInitialized(_this), "tl", void 0);\n\n    Spritesheet_get(Spritesheet_getPrototypeOf(_default.prototype), "init", Spritesheet_assertThisInitialized(_this)).call(Spritesheet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Spritesheet_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Spritesheet_DEBUG && console.log(Spritesheet_LOG, \'options:\', this.options); // Prepare\n      //#BUG: getBoundingClientRect() is always non-scaled in global space\n      // let bounds = this.element.getBoundingClientRect();\n      // !(this.options.width) && (this.options.width = bounds.width); \n      // !(this.options.height) && (this.options.height = bounds.height);\n      // offsetWidth/offsetHeight seems to work better with scaling\n\n      !this.options.width && (this.options.width = this.element.offsetWidth);\n      !this.options.height && (this.options.height = this.element.offsetHeight); // // Set background image\n\n      this.element.style.backgroundImage = "url(".concat(this.options.src, ")");\n      this.element.style.backgroundPosition = "0 0";\n      this.element.style.backgroundSize = "".concat(this.options.width * this.options.steps, "px");\n      this.element.style.backgroundRepeat = "no-repeat";\n      this.tl = gsap.timeline({\n        paused: true,\n        repeat: this.options.loop ? -1 : 0\n      });\n      this.tl.add(gsap.to(this.element, {\n        duration: this.options.duration / 1000,\n        backgroundPositionX: "-".concat(this.options.width * (this.options.steps - 1), "px"),\n        ease: "steps(".concat(this.options.steps - 1, ")")\n      }));\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.tl.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.tl.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nSpritesheet_defineProperty(Spritesheet_default, "manifest", {\n  id: \'Spritesheet\',\n  options: {\n    trigger: \'click\',\n    loop: false,\n    duration: 500,\n    width: undefined,\n    height: undefined,\n    steps: undefined\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/Jump.js\nfunction Jump_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Jump_typeof = function _typeof(obj) { return typeof obj; }; } else { Jump_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Jump_typeof(obj); }\n\nfunction Jump_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Jump_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Jump_createClass(Constructor, protoProps, staticProps) { if (protoProps) Jump_defineProperties(Constructor.prototype, protoProps); if (staticProps) Jump_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Jump_possibleConstructorReturn(self, call) { if (call && (Jump_typeof(call) === "object" || typeof call === "function")) { return call; } return Jump_assertThisInitialized(self); }\n\nfunction Jump_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Jump_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Jump_setPrototypeOf(subClass, superClass); }\n\nfunction Jump_setPrototypeOf(o, p) { Jump_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Jump_setPrototypeOf(o, p); }\n\nfunction Jump_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Jump_get = Reflect.get; } else { Jump_get = function _get(target, property, receiver) { var base = Jump_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Jump_get(target, property, receiver || target); }\n\nfunction Jump_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Jump_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Jump_getPrototypeOf(o) { Jump_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Jump_getPrototypeOf(o); }\n\nfunction Jump_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Jump_LOG = \'[ FX : Jump ]\';\nvar Jump_DEBUG = false;\n\nvar Jump_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Jump_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Jump_classCallCheck(this, _default);\n\n    _this = Jump_possibleConstructorReturn(this, Jump_getPrototypeOf(_default).apply(this, arguments));\n\n    Jump_defineProperty(Jump_assertThisInitialized(_this), "initial", void 0);\n\n    Jump_get(Jump_getPrototypeOf(_default.prototype), "init", Jump_assertThisInitialized(_this)).call(Jump_assertThisInitialized(_this));\n\n    Jump_get(Jump_getPrototypeOf(_default.prototype), "start", Jump_assertThisInitialized(_this)).call(Jump_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Jump_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Jump_DEBUG && console.log(Jump_LOG, \'init()\', this.options);\n      this.initial = {\n        y: gsap.getProperty(this.element, \'y\')\n      };\n      Jump_DEBUG && console.log(Jump_LOG, \'this.initial\', this.initial);\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Jump_DEBUG && console.log(Jump_LOG, \'start()\');\n      gsap.to(this.element, {\n        y: this.initial.y - 20,\n        duration: 0.4,\n        ease: \'power.out(4)\'\n      });\n      gsap.to(this.element, {\n        y: this.initial.y,\n        duration: 0.5,\n        delay: 0.5,\n        ease: \'bounce.out(20)\'\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nJump_defineProperty(Jump_default, "manifest", {\n  id: \'jump\',\n  options: {}\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/HandCursor.js\nfunction HandCursor_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { HandCursor_typeof = function _typeof(obj) { return typeof obj; }; } else { HandCursor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return HandCursor_typeof(obj); }\n\nfunction HandCursor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HandCursor_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HandCursor_createClass(Constructor, protoProps, staticProps) { if (protoProps) HandCursor_defineProperties(Constructor.prototype, protoProps); if (staticProps) HandCursor_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction HandCursor_possibleConstructorReturn(self, call) { if (call && (HandCursor_typeof(call) === "object" || typeof call === "function")) { return call; } return HandCursor_assertThisInitialized(self); }\n\nfunction HandCursor_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HandCursor_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) HandCursor_setPrototypeOf(subClass, superClass); }\n\nfunction HandCursor_setPrototypeOf(o, p) { HandCursor_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HandCursor_setPrototypeOf(o, p); }\n\nfunction HandCursor_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { HandCursor_get = Reflect.get; } else { HandCursor_get = function _get(target, property, receiver) { var base = HandCursor_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return HandCursor_get(target, property, receiver || target); }\n\nfunction HandCursor_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = HandCursor_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction HandCursor_getPrototypeOf(o) { HandCursor_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HandCursor_getPrototypeOf(o); }\n\nfunction HandCursor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar HandCursor_LOG = \'[ FX : HandCursor ]\';\nvar HandCursor_DEBUG = true;\n\nvar HandCursor_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  HandCursor_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    HandCursor_classCallCheck(this, _default);\n\n    _this = HandCursor_possibleConstructorReturn(this, HandCursor_getPrototypeOf(_default).apply(this, arguments));\n\n    HandCursor_get(HandCursor_getPrototypeOf(_default.prototype), "init", HandCursor_assertThisInitialized(_this)).call(HandCursor_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  HandCursor_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      HandCursor_DEBUG && console.log(HandCursor_LOG, \'init()\', this.options);\n      this.element.style.cursor = \'pointer\';\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nHandCursor_defineProperty(HandCursor_default, "manifest", {\n  id: \'hand-cursor\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/Debugger.js\nfunction Debugger_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Debugger_typeof = function _typeof(obj) { return typeof obj; }; } else { Debugger_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Debugger_typeof(obj); }\n\nfunction Debugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Debugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Debugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Debugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Debugger_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Debugger_possibleConstructorReturn(self, call) { if (call && (Debugger_typeof(call) === "object" || typeof call === "function")) { return call; } return Debugger_assertThisInitialized(self); }\n\nfunction Debugger_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Debugger_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Debugger_setPrototypeOf(subClass, superClass); }\n\nfunction Debugger_setPrototypeOf(o, p) { Debugger_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Debugger_setPrototypeOf(o, p); }\n\nfunction Debugger_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Debugger_get = Reflect.get; } else { Debugger_get = function _get(target, property, receiver) { var base = Debugger_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Debugger_get(target, property, receiver || target); }\n\nfunction Debugger_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Debugger_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Debugger_getPrototypeOf(o) { Debugger_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Debugger_getPrototypeOf(o); }\n\nfunction Debugger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Debugger_LOG = \'[ FX : Debugger ]\';\nvar Debugger_DEBUG = true;\n\nvar Debugger_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Debugger_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Debugger_classCallCheck(this, _default);\n\n    _this = Debugger_possibleConstructorReturn(this, Debugger_getPrototypeOf(_default).apply(this, arguments));\n\n    Debugger_get(Debugger_getPrototypeOf(_default.prototype), "init", Debugger_assertThisInitialized(_this)).call(Debugger_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Debugger_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      console.log(\'\\n\\n\');\n\n      function getLocalBoundingClientRect(el) {\n        var a = el.getBoundingClientRect();\n        var b = el.parentNode.getBoundingClientRect();\n        return {\n          left: a.left - b.left,\n          top: a.top - b.top,\n          width: a.width,\n          height: a.height\n        };\n      } // Client Rect\n\n\n      var clientRect = this.element.getBoundingClientRect();\n      console.log(\'clientRect:\', clientRect);\n      var parentClientRect = this.element.parentNode.getBoundingClientRect();\n      console.log(\'parentClientRect:\', parentClientRect);\n      console.log(\'local rect:\', getLocalBoundingClientRect(this.element));\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nDebugger_defineProperty(Debugger_default, "manifest", {\n  id: \'Debugger\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/GlitchCanvas.js\nfunction GlitchCanvas_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchCanvas_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchCanvas_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchCanvas_typeof(obj); }\n\nfunction GlitchCanvas_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchCanvas_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchCanvas_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchCanvas_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchCanvas_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchCanvas_possibleConstructorReturn(self, call) { if (call && (GlitchCanvas_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchCanvas_assertThisInitialized(self); }\n\nfunction GlitchCanvas_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchCanvas_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchCanvas_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchCanvas_setPrototypeOf(o, p) { GlitchCanvas_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchCanvas_setPrototypeOf(o, p); }\n\nfunction GlitchCanvas_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchCanvas_get = Reflect.get; } else { GlitchCanvas_get = function _get(target, property, receiver) { var base = GlitchCanvas_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchCanvas_get(target, property, receiver || target); }\n\nfunction GlitchCanvas_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchCanvas_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchCanvas_getPrototypeOf(o) { GlitchCanvas_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchCanvas_getPrototypeOf(o); }\n\nfunction GlitchCanvas_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchCanvas_LOG = \'[ FX : GlitchCanvas ]\';\nvar GlitchCanvas_DEBUG = true;\n\nvar GlitchCanvas_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchCanvas_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchCanvas_classCallCheck(this, _default);\n\n    _this = GlitchCanvas_possibleConstructorReturn(this, GlitchCanvas_getPrototypeOf(_default).apply(this, arguments));\n\n    GlitchCanvas_get(GlitchCanvas_getPrototypeOf(_default.prototype), "init", GlitchCanvas_assertThisInitialized(_this)).call(GlitchCanvas_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  GlitchCanvas_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      //---\n      // Inspired by https://codepen.io/Blummed/pen/lCjiu?editors=0010\n      console.log(GlitchCanvas_LOG, \'options:\', this.options); // Get the device pixel ratio, falling back to 1.\n\n      var dpr = window.devicePixelRatio || 1; // Prepare elements\n\n      this.original = this.element; // let bounds = this.original.getBoundingClientRect();\n      // let computedStyle = window.getComputedStyle(this.original);\n      // Replace element /w canvas\n\n      this.element = document.createElement(\'canvas\');\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.original.style.opacity = .1;\n      var canvas = this.element;\n      var context = canvas.getContext(\'2d\'),\n          img = new Image(),\n          w,\n          h,\n          offset,\n          glitchInterval,\n          scale;\n      context.scale(dpr, dpr);\n      img.src = this.original.getAttribute(\'src\');\n\n      img.onload = function () {\n        init();\n        window.onresize = init;\n      };\n\n      var init = function init() {\n        clearInterval(glitchInterval);\n\n        var bounds = _this2.original.getBoundingClientRect();\n\n        var computedStyle = window.getComputedStyle(_this2.original);\n        canvas.style.width = computedStyle.width;\n        canvas.style.height = computedStyle.height;\n        canvas.style.left = computedStyle.left;\n        canvas.style.top = computedStyle.top;\n        canvas.style.transform = computedStyle.transform;\n        canvas.width = w = bounds.width * dpr;\n        canvas.height = h = bounds.height * dpr;\n        scale = img.width / w;\n        glitchInterval = setInterval(function () {\n          clear();\n          setTimeout(glitchImg, randInt(250, 1000));\n        }, 300);\n      };\n\n      var clear = function clear() {\n        context.clearRect(0, 0, w * dpr, h * dpr);\n      };\n\n      var glitchImg = function glitchImg() {\n        for (var i = 0; i < randInt(1, 13); i++) {\n          var x = Math.random() * w * dpr;\n          var y = Math.random() * h * dpr;\n          var spliceWidth = w * dpr - x;\n          var spliceHeight = randInt(5, h * dpr / 3); // context.drawImage(canvas, 0, y, spliceWidth, spliceHeight, x, y, spliceWidth*dpr, spliceHeight*dpr);\n          // context.drawImage(canvas, spliceWidth, y, x, spliceHeight, 0, y, x, spliceHeight*dpr);\n          // WORKING\n          // context.drawImage(img, 0, 200, img.width, 100, 0, 200/scale, w, 100/scale);\n\n          context.drawImage(img, 0, 200, img.width, 100, 0, 200 / scale, w, 100 / scale);\n        }\n      };\n\n      var randInt = function randInt(a, b) {\n        return ~~(Math.random() * (b - a) + a);\n      };\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchCanvas_defineProperty(GlitchCanvas_default, "manifest", {\n  id: \'glitch-canvas\',\n  options: {\n    trigger: \'hover\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/GlitchEasel.js\nfunction GlitchEasel_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchEasel_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchEasel_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchEasel_typeof(obj); }\n\nfunction GlitchEasel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchEasel_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchEasel_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchEasel_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchEasel_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchEasel_possibleConstructorReturn(self, call) { if (call && (GlitchEasel_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchEasel_assertThisInitialized(self); }\n\nfunction GlitchEasel_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchEasel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchEasel_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchEasel_setPrototypeOf(o, p) { GlitchEasel_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchEasel_setPrototypeOf(o, p); }\n\nfunction GlitchEasel_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchEasel_get = Reflect.get; } else { GlitchEasel_get = function _get(target, property, receiver) { var base = GlitchEasel_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchEasel_get(target, property, receiver || target); }\n\nfunction GlitchEasel_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchEasel_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchEasel_getPrototypeOf(o) { GlitchEasel_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchEasel_getPrototypeOf(o); }\n\nfunction GlitchEasel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchEasel_LOG = \'[ FX : GlitchEasel ]\';\nvar GlitchEasel_DEBUG = true;\n\nvar GlitchEasel_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchEasel_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchEasel_classCallCheck(this, _default);\n\n    _this = GlitchEasel_possibleConstructorReturn(this, GlitchEasel_getPrototypeOf(_default).apply(this, arguments));\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "src", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "canvas", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "stage", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "width", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "height", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "dpr", !window.devicePixelRatio ? 1 : window.devicePixelRatio >= 2 ? 2 : 1);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "segments", []);\n\n    GlitchEasel_get(GlitchEasel_getPrototypeOf(_default.prototype), "init", GlitchEasel_assertThisInitialized(_this)).call(GlitchEasel_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  GlitchEasel_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      // Save original image\n      this.original = this.element;\n      this.src = this.original.getAttribute(\'src\'); // Create canvas\n\n      var canvas = this.canvas = document.createElement(\'canvas\');\n      this.original.getAttribute(\'id\') && canvas.setAttribute(\'id\', this.original.getAttribute(\'id\'));\n      this.stage = new createjs.Stage(this.canvas);\n      this.original.parentNode.insertBefore(this.canvas, this.original.nextSibling);\n      this.original.style.opacity = 0;\n      this.original.style.pointerEvents = \'none\';\n      var computedStyle = window.getComputedStyle(this.original);\n      canvas.style.width = computedStyle.width;\n      canvas.style.height = computedStyle.height;\n      canvas.style.left = computedStyle.left;\n      canvas.style.top = computedStyle.top;\n      canvas.style.transform = computedStyle.transform; // canvas.style.pointerEvents = \'none\';\n\n      this.width = parseInt(computedStyle.width) * this.dpr;\n      this.height = parseInt(computedStyle.height) * this.dpr; // let rect = canvas.getBoundingClientRect();\n      // canvas.width = rect.width * this.dpr;\n      // canvas.height = rect.height * this.dpr;\n      // canvas.getContext(\'2d\').scale(this.dpr, this.dpr);\n\n      canvas.width = canvas.clientWidth * this.dpr;\n      canvas.height = canvas.clientHeight * this.dpr;\n      canvas.getContext(\'2d\').scale(this.dpr, this.dpr);\n      this.element = this.canvas; // this.original.parentNode.removeChild(this.original);\n      // this.original.remove();\n\n      this.original.removeAttribute(\'id\'); // Create segments\n\n      var seedIndex = 0,\n          top = 0;\n\n      while (true) {\n        var seed = Math.round(this.options.seed[seedIndex] * this.options.factor);\n        var image = new createjs.Bitmap(this.src);\n        var shape = new createjs.Shape();\n        shape.graphics.beginFill("#FFFFFF").drawRect(0, top, this.width, seed);\n        image.mask = shape;\n        this.stage.addChild(image);\n        this.segments.push(image); // End\n\n        if (top >= parseInt(computedStyle.height) * this.dpr) break; // Iterate \n\n        top += seed;\n        seedIndex = seedIndex >= this.options.seed.length - 1 ? 0 : ++seedIndex;\n      } // Timeline\n\n\n      this.timeline = gsap.timeline({\n        paused: true,\n        delay: this.options.delay / 1000,\n        repeat: this.options.repeat,\n        repeatDelay: this.options.repeatDelay / 1000,\n        yoyo: this.options.yoyo,\n        onUpdate: this.stage.update.bind(this.stage)\n      });\n      this.segments.forEach(function (segment, index) {\n        _this2.timeline.from(segment, {\n          x: (Math.random() - .5) * 20 * _this2.options.power,\n          alpha: 0,\n          duration: 0.5,\n          ease: _this2.options.easeing\n        }, "".concat(index * _this2.options.stagger / 1000));\n      });\n      this.timeline.timeScale(this.timeline.duration() / (this.options.duration / 1000));\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.timeline.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.timeline.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchEasel_defineProperty(GlitchEasel_default, "manifest", {\n  id: \'glitch-easel\',\n  options: {\n    trigger: \'hover\',\n    duration: 1000,\n    delay: 0,\n    repeat: 0,\n    repeatDelay: 1000,\n    yoyo: true,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 10,\n    power: 80,\n    stagger: 10,\n    easing: \'power4.inOut\' // back.out(3),\n\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/GlitchAppear.js\nfunction GlitchAppear_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchAppear_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchAppear_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchAppear_typeof(obj); }\n\nfunction GlitchAppear_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchAppear_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchAppear_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchAppear_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchAppear_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchAppear_possibleConstructorReturn(self, call) { if (call && (GlitchAppear_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchAppear_assertThisInitialized(self); }\n\nfunction GlitchAppear_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchAppear_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchAppear_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchAppear_setPrototypeOf(o, p) { GlitchAppear_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchAppear_setPrototypeOf(o, p); }\n\nfunction GlitchAppear_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchAppear_get = Reflect.get; } else { GlitchAppear_get = function _get(target, property, receiver) { var base = GlitchAppear_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchAppear_get(target, property, receiver || target); }\n\nfunction GlitchAppear_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchAppear_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchAppear_getPrototypeOf(o) { GlitchAppear_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchAppear_getPrototypeOf(o); }\n\nfunction GlitchAppear_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchAppear_LOG = \'[ FX : GlitchAppear ]\';\nvar GlitchAppear_DEBUG = true;\n\nvar GlitchAppear_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchAppear_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchAppear_classCallCheck(this, _default);\n\n    _this = GlitchAppear_possibleConstructorReturn(this, GlitchAppear_getPrototypeOf(_default).apply(this, arguments));\n    _this.original;\n    _this.computedStyle;\n\n    GlitchAppear_get(GlitchAppear_getPrototypeOf(_default.prototype), "init", GlitchAppear_assertThisInitialized(_this)).call(GlitchAppear_assertThisInitialized(_this)); // super.start();\n\n\n    return _this;\n  }\n\n  GlitchAppear_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      GlitchAppear_DEBUG && console.log(GlitchAppear_LOG, \'init()\', this.options); // Prepare elements\n\n      this.original = this.element;\n      var computedStyle = this.computedStyle = window.getComputedStyle(this.original); // Wrap everything in div\n\n      this.element = document.createElement(\'div\');\n      this.element.style.position = computedStyle.position;\n      this.element.style.width = computedStyle.width;\n      this.element.style.height = computedStyle.height;\n      this.element.style.top = computedStyle.top;\n      this.element.style.left = computedStyle.left; // this.element.style.backgroundColor = \'#BADA55\';\n\n      this.element.style.overflow = \'hidden\';\n      this.element.setAttribute(\'mojo-fx-glitch\', this.original.getAttribute(\'mojo-fx-glitch\'));\n      this.original.removeAttribute(\'mojo-fx-glitch\');\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.element.appendChild(this.original); // Wrap original in div (for masking etc.)\n\n      var layerWrapper = document.createElement(\'div\');\n      this.original.parentNode.insertBefore(layerWrapper, this.original);\n      layerWrapper.appendChild(this.original);\n      this.original = layerWrapper; // Generate Elements\n\n      this.generateElements();\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      GlitchAppear_DEBUG && console.log(GlitchAppear_LOG, \'start()\');\n      var glitched = this.element.querySelectorAll(\'.glitched\');\n      gsap.set(this.original, {\n        opacity: 0\n      });\n      gsap.set(glitched, {\n        opacity: 0\n      });\n      var tl = gsap.timeline({\n        delay: this.options.delay / 1000\n      });\n      glitched.forEach(function (item, index) {\n        // let power = 20;\n        var power = 30;\n        var layerTl = gsap.timeline();\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.2,\n          x: (Math.random() - 0.5) * power\n        }, "+=0.02");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.4,\n          x: 0\n        }, "+=0.02");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.6,\n          x: (Math.random() - 0.5) * power\n        }, "+=0");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.8,\n          x: 0\n        }, "+=0.02");\n        layerTl.to({}, {\n          duration: 0.02\n        });\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: (Math.random() - 0.5) * power\n        }, "+=0"); // layerTl.to(item, {duration: 0.04, opacity: 1, x: 0}, `+=0.02`);\n        // layerTl.to(item, {duration: 0.04, opacity: 1, x: (Math.random()-0.5)*power}, `+=0.02`);\n\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: 0\n        }, "+=0.02");\n        tl.add(layerTl, index / 10); // tl.add( layerTl, 0.5 );\n      }); // tl.to(this.original, {duration: 0.2, opacity: 1}, .5);\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {\n      // console.log(this.computedStyle.width);\n      for (var i = 0; i < 10; i++) {\n        var clone = this.original.cloneNode(true);\n        clone.classList.add(\'glitched\');\n        clone.style.position = \'absolute\';\n        clone.style.top = "".concat(i * 60, "px");\n        clone.style.left = 0;\n        clone.style.width = this.computedStyle.width; // clone.style.height = \'30px\';\n\n        clone.style.height = "".concat(5 + Math.random() * 80, "px"); // clone.style.filter = \'grayscale(10%)\';\n        // clone.style.filter = `brightness(1.04)`;\n\n        clone.style.overflow = \'hidden\';\n        var child = clone.firstChild;\n        child.style.position = \'absolute\';\n        child.style.top = "".concat(i * -60, "px");\n        child.style.left = \'0px\';\n        this.element.appendChild(clone);\n      }\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchAppear_defineProperty(GlitchAppear_default, "manifest", {\n  id: \'GlitchAppear\',\n  options: {\n    delay: 0\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/GlitchBase.js\nfunction GlitchBase_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchBase_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchBase_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchBase_typeof(obj); }\n\nfunction GlitchBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchBase_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchBase_possibleConstructorReturn(self, call) { if (call && (GlitchBase_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchBase_assertThisInitialized(self); }\n\nfunction GlitchBase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchBase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchBase_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchBase_setPrototypeOf(o, p) { GlitchBase_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchBase_setPrototypeOf(o, p); }\n\nfunction GlitchBase_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchBase_get = Reflect.get; } else { GlitchBase_get = function _get(target, property, receiver) { var base = GlitchBase_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchBase_get(target, property, receiver || target); }\n\nfunction GlitchBase_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchBase_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchBase_getPrototypeOf(o) { GlitchBase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchBase_getPrototypeOf(o); }\n\nfunction GlitchBase_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchBase_LOG = \'[ FX : GlitchBase ]\';\nvar GlitchBase_DEBUG = true;\n\nvar GlitchBase_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchBase_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchBase_classCallCheck(this, _default);\n\n    _this = GlitchBase_possibleConstructorReturn(this, GlitchBase_getPrototypeOf(_default).apply(this, arguments));\n    _this.original;\n    _this.computedStyle;\n    _this.segments = [];\n\n    GlitchBase_get(GlitchBase_getPrototypeOf(_default.prototype), "init", GlitchBase_assertThisInitialized(_this)).call(GlitchBase_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  GlitchBase_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      GlitchBase_DEBUG && console.log(GlitchBase_LOG, \'init()\', this.options); // Prepare elements\n\n      this.original = this.element;\n      var computedStyle = this.computedStyle = window.getComputedStyle(this.original); // Wrap everything in div\n\n      this.element = document.createElement(\'div\');\n      this.element.style.position = computedStyle.position;\n      this.element.style.width = computedStyle.width;\n      this.element.style.height = computedStyle.height; // Ignore transforms\n\n      this.element.style.top = computedStyle.top;\n      this.element.style.left = computedStyle.left;\n      this.element.style.transform = computedStyle.transform; // Incorporate transforms\n      // console.log(\'bound\', bound);\n      // this.element.style.top = bound.top+\'px\';\n      // this.element.style.left = bound.left+\'px\';\n      // this.element.style.backgroundColor = \'#BADA55\';\n      // this.element.style.overflow = \'hidden\';\n\n      this.element.setAttribute(\'mojo-fx-glitch\', this.original.getAttribute(\'mojo-fx-glitch\'));\n      this.original.removeAttribute(\'mojo-fx-glitch\');\n      this.original.style.pointerEvents = \'none\';\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.element.appendChild(this.original); // Wrap original in div (for masking etc.)\n\n      var layerWrapper = document.createElement(\'div\');\n      layerWrapper.style.pointerEvents = \'none\';\n      this.original.parentNode.insertBefore(layerWrapper, this.original);\n      layerWrapper.appendChild(this.original);\n      this.original = layerWrapper; // Generate Elements\n\n      this.generateElements();\n      console.log(GlitchBase_LOG, \'generated\');\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {\n      // console.log(this.computedStyle.width);\n      var seedIndex = 0,\n          top = 0,\n          i = 0;\n\n      while (true) {\n        var seed = this.options.seed[seedIndex] * this.options.factor;\n        var clone = this.original.cloneNode(true);\n        clone.classList.add(\'glitched\');\n        clone.style.position = \'absolute\';\n        clone.style.top = "".concat(top, "px");\n        clone.style.left = \'0px\';\n        clone.style.width = this.computedStyle.width; // clone.style.backgroundColor = \'DeepPink\';\n\n        clone.style.height = "".concat(seed, "px"); // clone.style.filter = \'grayscale(100%)\';\n        // clone.style.filter = `brightness(1.04)`;\n\n        clone.style.overflow = \'hidden\';\n        clone.style.pointerEvents = \'none\';\n        var child = clone.firstChild;\n        child.style.position = \'absolute\';\n        child.style.top = "-".concat(top, "px");\n        child.style.left = \'0px\';\n        child.style.transform = \'none\';\n        child.style.pointerEvents = \'none\';\n        this.segments.push(clone);\n        this.element.appendChild(clone); // End\n\n        if (top >= parseInt(this.computedStyle.height)) break; // Iterate\n        // top += seed;\n\n        top += seed - 1; // Note: We need 1px overlapping to prevent white lines when scaling (rounding issue)\n\n        seedIndex = seedIndex >= this.options.seed.length - 1 ? 0 : ++seedIndex;\n        i++;\n      }\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchBase_defineProperty(GlitchBase_default, "manifest", {\n  id: \'glitch-base\',\n  options: {\n    delay: 0,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 20\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/GlitchInOut.js\nfunction GlitchInOut_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchInOut_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchInOut_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchInOut_typeof(obj); }\n\nfunction GlitchInOut_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchInOut_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchInOut_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchInOut_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchInOut_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchInOut_possibleConstructorReturn(self, call) { if (call && (GlitchInOut_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchInOut_assertThisInitialized(self); }\n\nfunction GlitchInOut_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchInOut_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchInOut_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchInOut_setPrototypeOf(o, p) { GlitchInOut_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchInOut_setPrototypeOf(o, p); }\n\nfunction GlitchInOut_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction GlitchInOut_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchInOut_get = Reflect.get; } else { GlitchInOut_get = function _get(target, property, receiver) { var base = GlitchInOut_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchInOut_get(target, property, receiver || target); }\n\nfunction GlitchInOut_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchInOut_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchInOut_getPrototypeOf(o) { GlitchInOut_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchInOut_getPrototypeOf(o); }\n\n// Experimental Effect\n\nvar GlitchInOut_LOG = \'[ FX : GlitchInOut ]\';\nvar GlitchInOut_DEBUG = false;\n\nvar GlitchInOut_default =\n/*#__PURE__*/\nfunction (_GlitchBase) {\n  GlitchInOut_inherits(_default, _GlitchBase);\n\n  function _default() {\n    var _this;\n\n    GlitchInOut_classCallCheck(this, _default);\n\n    _this = GlitchInOut_possibleConstructorReturn(this, GlitchInOut_getPrototypeOf(_default).apply(this, arguments));\n    _this.timeline;\n    return _this;\n  }\n\n  GlitchInOut_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      GlitchInOut_get(GlitchInOut_getPrototypeOf(_default.prototype), "init", this).call(this);\n\n      GlitchInOut_DEBUG && console.log(GlitchInOut_LOG, \'init()\', this.options);\n      this.original.style.opacity = 0;\n      this.timeline = gsap.timeline({\n        paused: true,\n        delay: this.options.delay / 1000\n      });\n      this.segments.forEach(function (item, index) {\n        item.style.opacity = 0;\n        gsap.set(item, {\n          x: (Math.random() - .5) * 20 * _this2.options.power,\n          force3D: true\n        });\n\n        _this2.timeline.to(item, {\n          duration: 0.4,\n          x: 0,\n          opacity: 1,\n          ease: \'Power4.inOut\',\n          force3D: true\n        }, 0);\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      GlitchInOut_DEBUG && console.log(GlitchInOut_LOG, \'start()\');\n      this.timeline.play(); // setTimeout(()=>{\n      //   this.timeline.reverse()\n      // }, this.options.delay+1900);\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      GlitchInOut_DEBUG && console.log(GlitchInOut_LOG, \'end()\');\n      this.timeline.reverse();\n    }\n  }]);\n\n  return _default;\n}(GlitchBase_default);\n\nGlitchInOut_defineProperty(GlitchInOut_default, "manifest", {\n  id: \'glitch-in-out\',\n  options: Object.assign({}, GlitchInOut_get(GlitchInOut_getPrototypeOf(GlitchInOut_default), "manifest", GlitchInOut_default).options, {\n    trigger: \'auto\',\n    delay: 0,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 20,\n    power: 40\n  })\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/Remove.js\nfunction Remove_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Remove_typeof = function _typeof(obj) { return typeof obj; }; } else { Remove_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Remove_typeof(obj); }\n\nfunction Remove_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Remove_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Remove_createClass(Constructor, protoProps, staticProps) { if (protoProps) Remove_defineProperties(Constructor.prototype, protoProps); if (staticProps) Remove_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Remove_possibleConstructorReturn(self, call) { if (call && (Remove_typeof(call) === "object" || typeof call === "function")) { return call; } return Remove_assertThisInitialized(self); }\n\nfunction Remove_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Remove_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Remove_setPrototypeOf(subClass, superClass); }\n\nfunction Remove_setPrototypeOf(o, p) { Remove_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Remove_setPrototypeOf(o, p); }\n\nfunction Remove_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Remove_get = Reflect.get; } else { Remove_get = function _get(target, property, receiver) { var base = Remove_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Remove_get(target, property, receiver || target); }\n\nfunction Remove_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Remove_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Remove_getPrototypeOf(o) { Remove_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Remove_getPrototypeOf(o); }\n\nfunction Remove_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Remove_LOG = \'[ FX : Remove ]\';\nvar Remove_DEBUG = true;\n\nvar Remove_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Remove_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Remove_classCallCheck(this, _default);\n\n    _this = Remove_possibleConstructorReturn(this, Remove_getPrototypeOf(_default).apply(this, arguments));\n\n    Remove_get(Remove_getPrototypeOf(_default.prototype), "init", Remove_assertThisInitialized(_this)).call(Remove_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Remove_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Remove_DEBUG && console.log(Remove_LOG, \'options:\', this.options);\n      this.element.parentElement.removeChild(this.element);\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nRemove_defineProperty(Remove_default, "manifest", {\n  id: \'remove\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/Fade.js\nfunction Fade_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Fade_typeof = function _typeof(obj) { return typeof obj; }; } else { Fade_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Fade_typeof(obj); }\n\nfunction Fade_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Fade_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Fade_createClass(Constructor, protoProps, staticProps) { if (protoProps) Fade_defineProperties(Constructor.prototype, protoProps); if (staticProps) Fade_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Fade_possibleConstructorReturn(self, call) { if (call && (Fade_typeof(call) === "object" || typeof call === "function")) { return call; } return Fade_assertThisInitialized(self); }\n\nfunction Fade_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Fade_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Fade_setPrototypeOf(subClass, superClass); }\n\nfunction Fade_setPrototypeOf(o, p) { Fade_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Fade_setPrototypeOf(o, p); }\n\nfunction Fade_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Fade_get = Reflect.get; } else { Fade_get = function _get(target, property, receiver) { var base = Fade_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Fade_get(target, property, receiver || target); }\n\nfunction Fade_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Fade_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Fade_getPrototypeOf(o) { Fade_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Fade_getPrototypeOf(o); }\n\nfunction Fade_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Fade_LOG = \'[ FX : Fade ]\';\nvar Fade_DEBUG = true;\n\nvar Fade_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Fade_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Fade_classCallCheck(this, _default);\n\n    _this = Fade_possibleConstructorReturn(this, Fade_getPrototypeOf(_default).apply(this, arguments));\n\n    Fade_get(Fade_getPrototypeOf(_default.prototype), "init", Fade_assertThisInitialized(_this)).call(Fade_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Fade_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Fade_DEBUG && console.log(Fade_LOG, \'init()\', this.options); //this.timeline = gsap.timeline({paused: true});\n\n      gsap.set(this.element, {\n        opacity: 0\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Fade_DEBUG && console.log(Fade_LOG, \'start()\');\n      gsap.to(this.element, {\n        delay: this.options.delay / 1000,\n        opacity: 1\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      Fade_DEBUG && console.log(Fade_LOG, \'end()\');\n      gsap.to(this.element, {\n        delay: this.options.delay / 1000,\n        opacity: 0\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nFade_defineProperty(Fade_default, "manifest", {\n  id: \'fade\',\n  options: {\n    trigger: \'auto\',\n    delay: 100\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/mojo/fx/experimental/PanZoom.js\nfunction PanZoom_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PanZoom_typeof = function _typeof(obj) { return typeof obj; }; } else { PanZoom_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PanZoom_typeof(obj); }\n\nfunction PanZoom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PanZoom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PanZoom_createClass(Constructor, protoProps, staticProps) { if (protoProps) PanZoom_defineProperties(Constructor.prototype, protoProps); if (staticProps) PanZoom_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PanZoom_possibleConstructorReturn(self, call) { if (call && (PanZoom_typeof(call) === "object" || typeof call === "function")) { return call; } return PanZoom_assertThisInitialized(self); }\n\nfunction PanZoom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PanZoom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PanZoom_setPrototypeOf(subClass, superClass); }\n\nfunction PanZoom_setPrototypeOf(o, p) { PanZoom_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PanZoom_setPrototypeOf(o, p); }\n\nfunction PanZoom_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { PanZoom_get = Reflect.get; } else { PanZoom_get = function _get(target, property, receiver) { var base = PanZoom_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return PanZoom_get(target, property, receiver || target); }\n\nfunction PanZoom_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PanZoom_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PanZoom_getPrototypeOf(o) { PanZoom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PanZoom_getPrototypeOf(o); }\n\nfunction PanZoom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar PanZoom_LOG = \'[ FX : PanZoom ]\';\nvar PanZoom_DEBUG = true;\n\nvar PanZoom_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  PanZoom_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    PanZoom_classCallCheck(this, _default);\n\n    _this = PanZoom_possibleConstructorReturn(this, PanZoom_getPrototypeOf(_default).apply(this, arguments));\n\n    PanZoom_get(PanZoom_getPrototypeOf(_default.prototype), "init", PanZoom_assertThisInitialized(_this)).call(PanZoom_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  PanZoom_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      console.log(PanZoom_LOG, \'options:\', this.options); // TEMP: XD HACK\n\n      this.element.parentNode.style.overflow = \'hidden\'; // Get stops\n\n      var stopElements = this.element.querySelectorAll(\'[mojo-fx-panzoom-stop]\');\n      PanZoom_DEBUG && console.log(PanZoom_LOG, \'stopElements:\', stopElements); // Process stops\n\n      this.stops = [];\n      stopElements.forEach(function (item) {\n        var options = item.getAttribute(\'mojo-fx-panzoom-stop\');\n        options = mojo.fx.FxScanner.extractOptions(options);\n        options = Object.assign({\n          delay: 3000\n        }, options);\n        var stop = {\n          el: item,\n          scale: _this2.element.offsetWidth / item.offsetWidth,\n          left: parseInt(window.getComputedStyle(item).transform.split(\'(\')[1].split(\',\')[4]),\n          top: parseInt(window.getComputedStyle(item).transform.split(\'(\')[1].split(\',\')[5]),\n          options: options\n        };\n\n        _this2.stops.push(stop);\n\n        item.style.opacity = 0;\n        item.style.pointerEvents = \'none\';\n      });\n      PanZoom_DEBUG && console.log(PanZoom_LOG, \'stops:\', this.stops); // Timeline\n\n      this.timeline = gsap.timeline({\n        paused: true\n      });\n      this.stops.forEach(function (item, index) {\n        _this2.timeline.to(_this2.element, {\n          scale: item.scale,\n          x: -item.left * item.scale,\n          y: -item.top * item.scale,\n          transformOrigin: \'0 0\',\n          delay: index > 0 && _this2.stops[index - 1].options.stop ? 0 : item.options.delay / 1000,\n          duration: 1.8,\n          ease: \'power4.inOut\',\n          force3D: true\n        });\n\n        item.options.stop && _this2.timeline.add(function () {\n          _this2.timeline.pause();\n\n          _this2.element.addEventListener(\'click\', function () {\n            _this2.timeline.play();\n          }, {\n            once: true\n          });\n        });\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.timeline.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nPanZoom_defineProperty(PanZoom_default, "manifest", {\n  id: \'panzoom\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// EXTERNAL MODULE: ./libs/nanoevents.js\nvar nanoevents = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/fusion/plugins/PluginBase.js\nfunction PluginBase_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PluginBase_typeof = function _typeof(obj) { return typeof obj; }; } else { PluginBase_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PluginBase_typeof(obj); }\n\nfunction PluginBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PluginBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PluginBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) PluginBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) PluginBase_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PluginBase_possibleConstructorReturn(self, call) { if (call && (PluginBase_typeof(call) === "object" || typeof call === "function")) { return call; } return PluginBase_assertThisInitialized(self); }\n\nfunction PluginBase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PluginBase_getPrototypeOf(o) { PluginBase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PluginBase_getPrototypeOf(o); }\n\nfunction PluginBase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PluginBase_setPrototypeOf(subClass, superClass); }\n\nfunction PluginBase_setPrototypeOf(o, p) { PluginBase_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PluginBase_setPrototypeOf(o, p); }\n\n\nvar PluginBase_LOG = \'[ PluginBase ]\';\nvar PluginBase_DEBUG = true;\n\nvar PluginBase_default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  PluginBase_inherits(_default, _NanoEvents);\n\n  function _default(scene, options) {\n    var _this;\n\n    PluginBase_classCallCheck(this, _default);\n\n    _this = PluginBase_possibleConstructorReturn(this, PluginBase_getPrototypeOf(_default).call(this));\n    _this.scene = scene;\n    _this.player = scene.player;\n    _this.options = options;\n    return _this;\n  }\n\n  PluginBase_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.options = Object.assign(this.manifest.options, this.options);\n      this.init();\n    }\n  }]);\n\n  return _default;\n}(nanoevents["a" /* default */]);\n\n\n// EXTERNAL MODULE: ./src/fusion/Const.js\nvar Const = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/fusion/plugins/wip/VisualDebugger.js\nfunction VisualDebugger_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { VisualDebugger_typeof = function _typeof(obj) { return typeof obj; }; } else { VisualDebugger_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return VisualDebugger_typeof(obj); }\n\nfunction VisualDebugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction VisualDebugger_possibleConstructorReturn(self, call) { if (call && (VisualDebugger_typeof(call) === "object" || typeof call === "function")) { return call; } return VisualDebugger_assertThisInitialized(self); }\n\nfunction VisualDebugger_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction VisualDebugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction VisualDebugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) VisualDebugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) VisualDebugger_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction VisualDebugger_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) VisualDebugger_setPrototypeOf(subClass, superClass); }\n\nfunction VisualDebugger_setPrototypeOf(o, p) { VisualDebugger_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return VisualDebugger_setPrototypeOf(o, p); }\n\nfunction VisualDebugger_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { VisualDebugger_get = Reflect.get; } else { VisualDebugger_get = function _get(target, property, receiver) { var base = VisualDebugger_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return VisualDebugger_get(target, property, receiver || target); }\n\nfunction VisualDebugger_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = VisualDebugger_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction VisualDebugger_getPrototypeOf(o) { VisualDebugger_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return VisualDebugger_getPrototypeOf(o); }\n\n// Experimental Plugin\n\n\nvar VisualDebugger_LOG = \'[ Plugin : VisualDebugger ]\';\nvar VisualDebugger_DEBUG = false;\n\nvar VisualDebugger_default =\n/*#__PURE__*/\nfunction (_PluginBase) {\n  VisualDebugger_inherits(_default, _PluginBase);\n\n  VisualDebugger_createClass(_default, null, [{\n    key: "manifest",\n    value: function manifest() {\n      return {\n        id: \'visualDebugger\',\n        options: {}\n      };\n    }\n  }]);\n\n  function _default() {\n    var _this;\n\n    VisualDebugger_classCallCheck(this, _default);\n\n    _this = VisualDebugger_possibleConstructorReturn(this, VisualDebugger_getPrototypeOf(_default).apply(this, arguments));\n    _this.manifest = _this.constructor.manifest();\n\n    VisualDebugger_get(VisualDebugger_getPrototypeOf(_default.prototype), "init", VisualDebugger_assertThisInitialized(_this)).call(VisualDebugger_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  VisualDebugger_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      VisualDebugger_DEBUG && console.log(VisualDebugger_LOG, \'init()\');\n      this.scene.on(Const["a" /* default */].SCENE_PRE_READY, this.on_scene_preReady.bind(this));\n      this.scene.on(Const["a" /* default */].SCENE_READY, this.on_scene_ready.bind(this));\n    }\n    /**\n     * on_scene_preReady\n     */\n\n  }, {\n    key: "on_scene_preReady",\n    value: function on_scene_preReady() {}\n    /**\n     * on_scene_ready\n     */\n\n  }, {\n    key: "on_scene_ready",\n    value: function on_scene_ready() {\n      var clone = this.scene.content.cloneNode(false);\n      clone.setAttribute(\'style\', this.scene.content.getAttribute(\'style\'));\n      clone.style.border = \'1px solid rgba(0,0,0,.2)\';\n      clone.style.boxSizing = \'border-box\';\n      clone.style.pointerEvents = \'none\';\n      this.scene.content.parentNode.appendChild(clone);\n    }\n  }]);\n\n  return _default;\n}(PluginBase_default);\n\n\n// CONCATENATED MODULE: ./src/fusion/plugins/wip/Panorama.js\nfunction Panorama_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Panorama_typeof = function _typeof(obj) { return typeof obj; }; } else { Panorama_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Panorama_typeof(obj); }\n\nfunction Panorama_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Panorama_possibleConstructorReturn(self, call) { if (call && (Panorama_typeof(call) === "object" || typeof call === "function")) { return call; } return Panorama_assertThisInitialized(self); }\n\nfunction Panorama_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Panorama_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Panorama_createClass(Constructor, protoProps, staticProps) { if (protoProps) Panorama_defineProperties(Constructor.prototype, protoProps); if (staticProps) Panorama_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Panorama_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Panorama_setPrototypeOf(subClass, superClass); }\n\nfunction Panorama_setPrototypeOf(o, p) { Panorama_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Panorama_setPrototypeOf(o, p); }\n\nfunction Panorama_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Panorama_get = Reflect.get; } else { Panorama_get = function _get(target, property, receiver) { var base = Panorama_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Panorama_get(target, property, receiver || target); }\n\nfunction Panorama_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Panorama_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Panorama_getPrototypeOf(o) { Panorama_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Panorama_getPrototypeOf(o); }\n\n// Experimental Plugin\n\n\nvar Panorama_LOG = \'[ Plugin : Panorama ]\';\nvar Panorama_DEBUG = true;\n\nvar Panorama_default =\n/*#__PURE__*/\nfunction (_PluginBase) {\n  Panorama_inherits(_default, _PluginBase);\n\n  Panorama_createClass(_default, null, [{\n    key: "manifest",\n    value: function manifest() {\n      return {\n        id: \'panorama\',\n        options: {\n          speed: 1\n        }\n      };\n    }\n  }]);\n\n  function _default() {\n    var _this;\n\n    Panorama_classCallCheck(this, _default);\n\n    _this = Panorama_possibleConstructorReturn(this, Panorama_getPrototypeOf(_default).apply(this, arguments));\n    _this.manifest = _this.constructor.manifest();\n\n    Panorama_get(Panorama_getPrototypeOf(_default.prototype), "init", Panorama_assertThisInitialized(_this)).call(Panorama_assertThisInitialized(_this));\n\n    _this.mouseX;\n    _this.lastScrollTo = 0;\n    return _this;\n  }\n\n  Panorama_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Panorama_DEBUG && console.log(Panorama_LOG, \'init()\');\n      this.scene.on(Const["a" /* default */].SCENE_PRE_READY, this.on_scene_preReady.bind(this));\n      this.scene.on(Const["a" /* default */].SCENE_READY, this.on_scene_ready.bind(this));\n    }\n    /**\n     * on_scene_preReady\n     */\n\n  }, {\n    key: "on_scene_preReady",\n    value: function on_scene_preReady() {\n      // Prepare scene\n      this.scene.element.style.overflowX = \'scroll\';\n      this.scene.content.style.overflow = \'unset\'; // // Tweak content container to get real width\n      // // scene.content.style.width = \'auto\';\n      // scene.content.style.right = \'unset\';\n      // // Prevent history back when scrolling to left on viewport\n      // // #TODO: Not preventing in Edge\n      // scene.element.addEventListener(\'mousewheel\', function(evt) {\n      //   if (evt.currentTarget.scrollLeft <= 0 && evt.deltaX < 0)  evt.preventDefault();\n      // }, {passive: false});\n      // #TODO: DECIDE ON THROTTLE\n\n      this.scene.element.addEventListener(\'mousemove\', mojo.FusionHelper.throttle(this.on_scene_mouseMove.bind(this), 50)); // 20fps\n\n      this.scene.element.addEventListener(\'click\', this.on_scene_click.bind(this));\n    }\n    /**\n     * on_scene_ready\n     */\n\n  }, {\n    key: "on_scene_ready",\n    value: function on_scene_ready() {\n      Panorama_DEBUG && console.log(Panorama_LOG, \'on_scene_ready()\');\n    }\n    /**\n     * on_scene_mouseMove\n     */\n\n  }, {\n    key: "on_scene_mouseMove",\n    value: function on_scene_mouseMove(evt) {\n      this.mouseX = evt.clientX - this.scene.element.getBoundingClientRect().left;\n    }\n    /**\n     * on_scene_click\n     */\n\n  }, {\n    key: "on_scene_click",\n    value: function on_scene_click(evt) {\n      // Bail if mouse is on interactive elements\n      if (evt.target.hasAttribute(\'mojo-interactive\')) return; // Bail if already moving/scrolling\n\n      if (gsap.isTweening(this.scene.element)) return;\n      var scene = this.scene; // Determine direction\n\n      var minScrollTo = 0;\n      var maxScrollTo = Math.round(scene.content.scrollWidth * scene.scale - scene.element.clientWidth);\n      var dir = this.mouseX - scene.element.clientWidth / 2 > 0 ? \'right\' : \'left\';\n      dir = scene.element.scrollLeft <= minScrollTo ? \'right\' : dir;\n      dir = scene.element.scrollLeft >= maxScrollTo ? \'left\' : dir;\n      Panorama_DEBUG && console.log(Panorama_LOG, \'dir:\', dir); //---\n      // step = scene width\n      // var currentIndex = Math.round(scene.element.scrollLeft/(scene.data.width * scene.scale));\n      // var scrollTo = ((dir==\'left\') ? currentIndex-1 : currentIndex+1) * (scene.data.width * scene.scale);\n      // scrollTo = (scrollTo <= minScrollTo) ? \'0\' : scrollTo;\n      // scrollTo = (scrollTo > maxScrollTo) ? maxScrollTo : scrollTo;\n      //---\n      // step = custom stops\n\n      var stops = this.options.stops;\n      if (!stops) console.error(Panorama_LOG, \'missing options "stops"\');\n      stops = stops.map(function (x) {\n        return Math.round(x * scene.scale);\n      });\n      stops.sort(function (a, b) {\n        return a - b;\n      });\n      Panorama_DEBUG && console.log(Panorama_LOG, \'stops\', stops);\n      var currentScrollCenter = Math.round(scene.element.scrollLeft + scene.element.clientWidth / 2 - (scene.element.clientWidth - scene.content.clientWidth * scene.scale) / 2); // DEBUG && console.log(LOG, \'currentScrollCenter\', currentScrollCenter);\n\n      var scrollTo;\n      var stop = 0;\n\n      if (dir == \'left\') {\n        // Find next smaller stop (relative to current scroll center)\n        var stopsReverse = stops.slice(0).reverse();\n\n        for (var i = 0; i < stopsReverse.length; i++) {\n          var item = stopsReverse[i];\n\n          if (item < currentScrollCenter) {\n            stop = item;\n            break;\n          }\n        }\n      } else {\n        // Find next higher stop (relative to current scroll center)\n        for (var i = 0; i < stops.length; i++) {\n          var item = stops[i];\n\n          if (item > currentScrollCenter + 1) {\n            stop = item;\n            break;\n          }\n        }\n      } // Calculate scroll new position\n\n\n      scrollTo = Math.floor(stop - scene.element.clientWidth / 2 + (scene.element.clientWidth - scene.content.clientWidth * scene.scale) / 2);\n      scrollTo = scrollTo <= minScrollTo ? \'0\' : scrollTo;\n      scrollTo = scrollTo > maxScrollTo ? maxScrollTo : scrollTo; // DEBUG && console.log(LOG, \'scrollTo\', scrollTo);\n      // Duration relative to distance\n\n      var duration = Math.abs(this.lastScrollTo - scrollTo) / 1200 / this.options.speed;\n      duration = duration < .2 ? .2 : duration; // DEBUG && console.log(LOG, \'speed\', this.options.speed);\n      // DEBUG && console.log(LOG, \'duration\', duration);\n      // Remember\n\n      this.lastScrollTo = scrollTo; // Tween    \n\n      gsap.isTweening(scene.element) && gsap.killTweensOf(scene.element);\n      gsap.to(scene.element, {\n        duration: duration,\n        ease: \'power4.inOut\',\n        scrollLeft: scrollTo,\n        onComplete: function onComplete() {\n          // updateCursorDir();\n          // Propagate custom_slide_active\n          scene.emit(\'custom_slide_active\', {\n            index: stops.indexOf(stop),\n            scrollTo: scrollTo\n          });\n        }\n      });\n    }\n  }]);\n\n  return _default;\n}(PluginBase_default);\n\n\n// EXTERNAL MODULE: ./style/fusion.scss\nvar fusion = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./src/mojo.js\n\n\n // import {FusionHelper} from \'./mojo/core/FusionHelper\';\n\n\n // Effects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar version = __webpack_require__(7).version;\n\nconsole.log(\'[ Mojo ]\', \'VERSION\', version); // Gsap Defaults\n\ngsap.defaults({\n  ease: "power2.inOut",\n  duration: 0.5\n});\ngsap.config({\n  force3D: true\n}); // Global Mojo instance\n\nwindow.mojo = new Mojo_default(); // Use Mojo instance as namespace for all classes\n\nObject.assign(window.mojo, {\n  // FusionHelper, // MOVED TO FUSION\n  // #TODO: Decide between FusionHelper.throttle and helper.throttle (lodash)\n  helper: {\n    throttle: lodash_throttle_default.a,\n    debounce: lodash_debounce_default.a\n  },\n  plugins: {\n    Panorama: Panorama_default,\n    VisualDebugger: VisualDebugger_default\n  },\n  fx: {\n    FxBase: FxBase["a" /* default */],\n    Debugger: Debugger_default,\n    FxScanner: FxScanner["a" /* default */],\n    Glitch: Glitch_default,\n    Magnet: Magnet_default,\n    Hide: Hide_default,\n    Particles: Particles_default,\n    HandCursor: HandCursor_default,\n    Jump: Jump_default,\n    GlitchAppear: GlitchAppear_default,\n    GlitchInOut: GlitchInOut_default,\n    GlitchCanvas: GlitchCanvas_default,\n    GlitchEasel: GlitchEasel_default,\n    TypeAnimation: TypeAnimation_default,\n    Spritesheet: Spritesheet_default,\n    Remove: Remove_default,\n    Fade: Fade_default,\n    PanZoom: PanZoom_default,\n    ex: {\n      anime: {\n        Magnet: anime_Magnet_default\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9jb3JlL0JyYWluLmpzP2Y3MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vam8vY29yZS9Nb2pvLmpzP2UwZWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vam8vZngvY29yZS9HbGl0Y2guanM/YTA2NCIsIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9jb3JlL01hZ25ldC5qcz9hYzI5Iiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2NvcmUvSGlkZS5qcz85MmExIiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9hbmltZS9NYWduZXQuanM/ZmIwMSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9leHBlcmltZW50YWwvVHlwZUFuaW1hdGlvbi5qcz84NDcwIiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9QYXJ0aWNsZXMuanM/MzBiOSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9leHBlcmltZW50YWwvU3ByaXRlc2hlZXQuanM/MTVhMiIsIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9leHBlcmltZW50YWwvSnVtcC5qcz81ODA3Iiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9IYW5kQ3Vyc29yLmpzP2VjNTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vam8vZngvZXhwZXJpbWVudGFsL0RlYnVnZ2VyLmpzPzc4NTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vam8vZngvZXhwZXJpbWVudGFsL0dsaXRjaENhbnZhcy5qcz83NWI3Iiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hFYXNlbC5qcz9jMzM0Iiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hBcHBlYXIuanM/NmY0NSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9leHBlcmltZW50YWwvR2xpdGNoQmFzZS5qcz8wYTAzIiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hJbk91dC5qcz85OTY1Iiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9SZW1vdmUuanM/MjU3MCIsIndlYnBhY2s6Ly8vLi9zcmMvbW9qby9meC9leHBlcmltZW50YWwvRmFkZS5qcz8xZGQzIiwid2VicGFjazovLy8uL3NyYy9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9QYW5ab29tLmpzPzI3MzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z1c2lvbi9wbHVnaW5zL1BsdWdpbkJhc2UuanM/NDMzNCIsIndlYnBhY2s6Ly8vLi9zcmMvZnVzaW9uL3BsdWdpbnMvd2lwL1Zpc3VhbERlYnVnZ2VyLmpzPzUzZjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z1c2lvbi9wbHVnaW5zL3dpcC9QYW5vcmFtYS5qcz8xMmY3Iiwid2VicGFjazovLy8uL3NyYy9tb2pvLmpzPzM5NjciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgTE9HID0gJ1sgQnJhaW4gXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnY29uc3RydWN0b3IoKScpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHApIHtcbiAgICAgIGNvbnNvbGUubG9nKExPRywgJ2FkZCgpIHA6JywgcCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufSgpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgQnJhaW4gZnJvbSAnLi9CcmFpbic7XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL2Z4L0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgTW9qbyBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJyYWluXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmJyYWluID0gbmV3IEJyYWluKCk7XG4gICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnY29uc3RydWN0b3IoKScpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRcbiAgICogRm9yIHBhcmFtZXRlcnMgYWxzbyBzZWUgYWRkQmVoYXZpb3IoKVxuICAgKiBAZXhhbXBsZVxuICAgKiBcbiAgICogIC8vIEVmZmVjdCBCZWhhdmlvclxuICAgKiAgbW9qby5hZGQoZWwsICdjbGljaycsIG1vam8uZnguTWFnbmV0LCB7ZGVsYXk6IDEwMH0pO1xuICAgKiBcbiAgICogIC8vIEN1c3RvbSBiZWhhdmlvclxuICAgKiAgbW9qby5hZGQoZWwsICd0b2dnbGUnLCB7XG4gICAqICAgIHN0YXJ0OiAoKSA9PiB7XG4gICAqICAgICAgY29uc29sZS5sb2coJ1NUQVJUJyk7XG4gICAqICAgIH0sXG4gICAqICAgIGVuZDogKCkgPT4ge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKCdFTkQnKTtcbiAgICogICAgfVxuICAgKiAgfSk7XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgLy8gRGVsZWdhdGUgZGVwZW5kaW5nIG9uIHNpZ25hdHVyZVxuICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdzdHJpbmcnIHx8IF90eXBlb2YoYXJndW1lbnRzWzFdKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXS50eXBlID09PSAnc3RyaW5nJykgJiYgYXJndW1lbnRzWzJdLnByb3RvdHlwZSBpbnN0YW5jZW9mIG1vam8uZnguRnhCYXNlKSB7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0QmVoYXZpb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRWxlbWVudCAmJiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ3N0cmluZycgfHwgX3R5cGVvZihhcmd1bWVudHNbMV0pID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdLnR5cGUgPT09ICdzdHJpbmcnKSAmJiBfdHlwZW9mKGFyZ3VtZW50c1syXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuYWRkQmVoYXZpb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKExPRywgJ2FkZCgpJywgJ3Vua25vd24gc2lnbmF0dXJlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBFZmZlY3QgQmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgaG9zdCBlbGVtZW50IHRvIGFkZCB0aGUgYmVoYXZpb3IgdG9cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHJpZ2dlciBUaGUgdHJpZ2dlciB0eXBlIChlLmcuIGNsaWNrLCBob3ZlciwgdG9nZ2xlIGV0Yy4pXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRS5nLiAnY2xpY2snIG9yIHt0eXBlOiAnaG92ZXInLCBhcmVhOiAnI2N1c3RvbS10cmlnZ2VyLWFyZWEnfVxuICAgICAqIEBwYXJhbSB7RnhCYXNlfSBGeCBUaGUgZWZmZWN0IGNsYXNzIHRvIGFwcGx5IChlLmcuIG1vam8uZnguTWFnbmV0KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZnhPcHRpb25zXSBPcHRpb25hbCBlZmZlY3Qgb3B0aW9ucyAoZS5nIHtzcGVlZDogMn0pXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZmZlY3RCZWhhdmlvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZmZlY3RCZWhhdmlvcihlbCwgdHJpZ2dlciwgRngsIGZ4T3B0aW9ucykge1xuICAgICAgLy8tLS1cbiAgICAgIC8vIENyZWF0ZSBmeFxuICAgICAgZnhPcHRpb25zID0gZnhPcHRpb25zID8gZnhPcHRpb25zIDoge307XG4gICAgICB2YXIgZnggPSBuZXcgRngoZWwsIGZ4T3B0aW9ucyk7XG4gICAgICBlbCA9IGZ4LmVsZW1lbnQ7XG4gICAgICB0aGlzLmFkZEJlaGF2aW9yKGVsLCB0cmlnZ2VyLCBmeCwgZnhPcHRpb25zID8gZnhPcHRpb25zLmlkIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGJlaGF2aW9yXG4gICAgICogKHN1cHBvcnRzIGF1dG9tYXRpYyBhcmVhIGRldGVjdGlvbjogaWYgbmV4dCBub2RlIGhhcyBhdHRyaWJ1dGUgXCJtb2pvLXRyaWdnZXItYXJlYVwiIClcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgaG9zdCBlbGVtZW50IHRvIGFkZCB0aGUgYmVoYXZpb3IgdG9cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHJpZ2dlciBUaGUgdHJpZ2dlciB0eXBlIChlLmcuIGNsaWNrLCBob3ZlciwgdG9nZ2xlIGV0Yy4pXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRS5nLiAnY2xpY2snIG9yIHt0eXBlOiAnaG92ZXInLCBhcmVhOiAnI2N1c3RvbS10cmlnZ2VyLWFyZWEnfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQWN0aW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbi5zdGFydCBTdGFydCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbi5lbmQgRW5kIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtpZF0gT3B0aW9uYWwgaWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEJlaGF2aW9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJlaGF2aW9yKGVsLCB0cmlnZ2VyLCBhY3Rpb24sIGlkKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdhZGRCZWhhdmlvcigpJywgZWwsIHRyaWdnZXIsIGFjdGlvbiwgaWQpO1xuICAgICAgdmFyIHRyaWdnZXJUeXBlID0gdHlwZW9mIHRyaWdnZXIgPT09ICdzdHJpbmcnID8gdHJpZ2dlciA6IHRyaWdnZXIudHlwZSxcbiAgICAgICAgICBzdGFuZGFyZCA9IHRydWUsXG4gICAgICAgICAgc3RhcnRUcmlnZ2VyLFxuICAgICAgICAgIGVuZFRyaWdnZXI7IC8vLS0tXG4gICAgICAvLyBBcmVhXG5cbiAgICAgIHZhciBhcmVhID0gdHlwZW9mIHRyaWdnZXIgPT09ICdzdHJpbmcnID8gZWwgOiB0eXBlb2YgdHJpZ2dlci5hcmVhID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodHJpZ2dlci5hcmVhKSA6IHRyaWdnZXIuYXJlYTtcblxuICAgICAgaWYgKGFyZWEgPT0gZWwpIHtcbiAgICAgICAgLy8gQXV0byBkZXRlY3QgYXJlYSAobmV4dCBub2RlIGhhcyBcIm1vam8tdHJpZ2dlci1hcmVhXCIgYXR0cmlidXRlKVxuICAgICAgICBpZiAoZWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIGVsLm5leHRFbGVtZW50U2libGluZy5oYXNBdHRyaWJ1dGUoJ21vam8tdHJpZ2dlci1hcmVhJykpIHtcbiAgICAgICAgICBpZiAoZWwubmV4dEVsZW1lbnRTaWJsaW5nLnRhZ05hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIGFyZWEgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmcuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmVhID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8tLS1cbiAgICAgIC8vIFRyaWdnZXIgdHlwZVxuXG5cbiAgICAgIHN3aXRjaCAodHJpZ2dlclR5cGUpIHtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgc3RhbmRhcmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgc3RhcnRUcmlnZ2VyID0gJ2NsaWNrJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgc3RhcnRUcmlnZ2VyID0gJ21vdXNlZW50ZXInO1xuICAgICAgICAgIGVuZFRyaWdnZXIgPSAnbW91c2VsZWF2ZSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG9nZ2xlJzpcbiAgICAgICAgICBzdGFydFRyaWdnZXIgPSAnY2xpY2snO1xuICAgICAgICAgIGVuZFRyaWdnZXIgPSAnY2xpY2snO1xuICAgICAgICAgIHN0YW5kYXJkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBlLmcuIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsIGJsdXIsIGZvY3VzIGV0Yy5cbiAgICAgICAgICBzdGFydFRyaWdnZXIgPSB0cmlnZ2VyVHlwZTtcbiAgICAgIH0gLy8tLS1cbiAgICAgIC8vIFNldHVwIHRyaWdnZXJpbmcgKGV2ZW50IGxpc3RlbmVycyBldGMuKVxuXG5cbiAgICAgIGlmIChzdGFuZGFyZCkge1xuICAgICAgICAvLyBzdGFydFRyaWdnZXIgJiYgYXJlYS5hZGRFdmVudExpc3RlbmVyKHN0YXJ0VHJpZ2dlciwgc3RhcnRGdW5jKTtcbiAgICAgICAgLy8gZW5kVHJpZ2dlciAmJiBhcmVhLmFkZEV2ZW50TGlzdGVuZXIoZW5kVHJpZ2dlciwgZW5kRnVuYyk7XG4gICAgICAgIHN0YXJ0VHJpZ2dlciAmJiBhY3Rpb24uc3RhcnQgJiYgYXJlYS5hZGRFdmVudExpc3RlbmVyKHN0YXJ0VHJpZ2dlciwgYWN0aW9uLnN0YXJ0LmJpbmQoYWN0aW9uLCBlbCkpO1xuICAgICAgICBlbmRUcmlnZ2VyICYmIGFjdGlvbi5lbmQgJiYgYXJlYS5hZGRFdmVudExpc3RlbmVyKGVuZFRyaWdnZXIsIGFjdGlvbi5lbmQuYmluZChhY3Rpb24sIGVsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgIGFjdGlvbi5zdGFydCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0b2dnbGUnOlxuICAgICAgICAgICAgdmFyIG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgIG9uID8gYWN0aW9uLnN0YXJ0KGVsKSA6IGFjdGlvbi5lbmQoZWwpO1xuICAgICAgICAgICAgICBvbiA9ICFvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8tLS1cbiAgICAgIC8vIE1lbW9yaXplIG9uIGVsZW1lbnQgbGV2ZWwgaWYgZnggaGFzIGlkXG5cblxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2FkZEJlaGF2aW9yKCknLCAnTWVtb3JpemUgb24gZWxlbWVudCB3aXRoIGlkOicsIGlkKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlRWxlbWVudChlbCk7XG4gICAgICAgIGVsLm1vam8uZngucHVzaChhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVFbGVtZW50KGVsKSB7XG4gICAgICAhZWwubW9qbyAmJiAoZWwubW9qbyA9IHtcbiAgICAgICAgZng6IFtdLFxuICAgICAgICBzY2FubmVkOiB7fVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufSgpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IEdsaXRjaCBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3JjXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2FudmFzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhZ2VcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhlaWdodFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRwclwiLCAhd2luZG93LmRldmljZVBpeGVsUmF0aW8gPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMiA/IDIgOiAxKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZWdtZW50c1wiLCBbXSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHRoaXMuc3JjID0gdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ3NyYycpOyAvLyBDcmVhdGUgY2FudmFzXG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ2lkJykgJiYgY2FudmFzLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLm9yaWdpbmFsLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICB0aGlzLnN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKHRoaXMuY2FudmFzKTtcbiAgICAgIHRoaXMub3JpZ2luYWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jYW52YXMsIHRoaXMub3JpZ2luYWwubmV4dFNpYmxpbmcpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMub3JpZ2luYWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5vcmlnaW5hbCk7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGNvbXB1dGVkU3R5bGUuaGVpZ2h0O1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBjb21wdXRlZFN0eWxlLmxlZnQ7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gY29tcHV0ZWRTdHlsZS50b3A7XG4gICAgICBjYW52YXMuc3R5bGUudHJhbnNmb3JtID0gY29tcHV0ZWRTdHlsZS50cmFuc2Zvcm07IC8vIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICB0aGlzLndpZHRoID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS53aWR0aCkgKiB0aGlzLmRwcjtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5oZWlnaHQpICogdGhpcy5kcHI7IC8vIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIHRoaXMuZHByO1xuICAgICAgLy8gY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgICAvLyBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuXG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLmRwcjtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jYW52YXM7IC8vIHRoaXMub3JpZ2luYWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm9yaWdpbmFsKTtcbiAgICAgIC8vIHRoaXMub3JpZ2luYWwucmVtb3ZlKCk7XG5cbiAgICAgIHRoaXMub3JpZ2luYWwucmVtb3ZlQXR0cmlidXRlKCdpZCcpOyAvLyBDcmVhdGUgc2VnbWVudHNcblxuICAgICAgdmFyIHNlZWRJbmRleCA9IDAsXG4gICAgICAgICAgdG9wID0gMDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHNlZWQgPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5zZWVkW3NlZWRJbmRleF0gKiB0aGlzLm9wdGlvbnMuZmFjdG9yKTtcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IGNyZWF0ZWpzLkJpdG1hcCh0aGlzLnNyYyk7XG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjRkZGRkZGXCIpLmRyYXdSZWN0KDAsIHRvcCwgdGhpcy53aWR0aCwgc2VlZCk7XG4gICAgICAgIGltYWdlLm1hc2sgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChpbWFnZSk7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChpbWFnZSk7IC8vIEVuZFxuXG4gICAgICAgIGlmICh0b3AgPj0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5oZWlnaHQpICogdGhpcy5kcHIpIGJyZWFrOyAvLyBJdGVyYXRlIFxuXG4gICAgICAgIHRvcCArPSBzZWVkO1xuICAgICAgICBzZWVkSW5kZXggPSBzZWVkSW5kZXggPj0gdGhpcy5vcHRpb25zLnNlZWQubGVuZ3RoIC0gMSA/IDAgOiArK3NlZWRJbmRleDtcbiAgICAgIH0gLy8gVGltZWxpbmVcblxuXG4gICAgICB0aGlzLnRpbWVsaW5lID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDAsXG4gICAgICAgIHJlcGVhdDogdGhpcy5vcHRpb25zLnJlcGVhdCxcbiAgICAgICAgcmVwZWF0RGVsYXk6IHRoaXMub3B0aW9ucy5yZXBlYXREZWxheSAvIDEwMDAsXG4gICAgICAgIHlveW86IHRoaXMub3B0aW9ucy55b3lvLFxuICAgICAgICBvblVwZGF0ZTogdGhpcy5zdGFnZS51cGRhdGUuYmluZCh0aGlzLnN0YWdlKVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQsIGluZGV4KSB7XG4gICAgICAgIF90aGlzMi50aW1lbGluZS5mcm9tKHNlZ21lbnQsIHtcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIC41KSAqIDIwICogX3RoaXMyLm9wdGlvbnMucG93ZXIsXG4gICAgICAgICAgYWxwaGE6IDAsXG4gICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICBlYXNlOiBfdGhpczIub3B0aW9ucy5lYXNlaW5nXG4gICAgICAgIH0sIFwiXCIuY29uY2F0KGluZGV4ICogX3RoaXMyLm9wdGlvbnMuc3RhZ2dlciAvIDEwMDApKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50aW1lbGluZS50aW1lU2NhbGUodGhpcy50aW1lbGluZS5kdXJhdGlvbigpIC8gKHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lLnBsYXkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIHRoaXMudGltZWxpbmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdnbGl0Y2gnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2hvdmVyJyxcbiAgICBkdXJhdGlvbjogMTAwMCxcbiAgICBkZWxheTogMCxcbiAgICByZXBlYXQ6IDAsXG4gICAgcmVwZWF0RGVsYXk6IDEwMDAsXG4gICAgeW95bzogdHJ1ZSxcbiAgICBzZWVkOiBbMSwgNiwgMywgMSwgMywgOCwgMiwgMSwgOSwgNCwgNywgMV0sXG4gICAgZmFjdG9yOiAxMCxcbiAgICBwb3dlcjogODAsXG4gICAgc3RhZ2dlcjogMTAsXG4gICAgZWFzaW5nOiAncG93ZXI0LmluT3V0JyAvLyBiYWNrLm91dCgzKSxcblxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBNYWduZXQgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBnc2FwLnRvKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBzY2FsZTogdGhpcy5vcHRpb25zLnNjYWxlLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICc1MCUgNTAlJyxcbiAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDAsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyAxMDAwLFxuICAgICAgICBlYXNlOiAncG93ZXI0Lm91dCg5KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgZ3NhcC5pc1R3ZWVuaW5nKHRoaXMuZWxlbWVudCkgJiYgZ3NhcC5raWxsVHdlZW5zT2YodGhpcy5lbGVtZW50LCAnc2NhbGUnKTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uIC8gMTAwMCxcbiAgICAgICAgZWFzZTogdGhpcy5vcHRpb25zLmVhc2VPdXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdtYWduZXQnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2hvdmVyJyxcbiAgICBkZWxheTogMCxcbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIHNjYWxlOiAxLjIsXG4gICAgZWFzZU91dDogJ2JhY2sub3V0KDMpJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBIaWRlIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdoaWRlJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdhdXRvJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uLy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBBbmltYXRlTWFnbmV0IChBbmltZSkgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFuXCIsIHZvaWQgMCk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb24odGhpcy5hbik7XG4gICAgICB0aGlzLmFuID0gYW5pbWUoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLmVsZW1lbnQsXG4gICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbnMuc2NhbGUsXG4gICAgICAgIGR1cmF0aW9uOiA2MDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VPdXRFeHBvJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAvLyBnc2FwLmlzVHdlZW5pbmcodGhpcy5lbGVtZW50KSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLmVsZW1lbnQpO1xuICAgICAgLy8gZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtzY2FsZTogMSwgZHVyYXRpb246IDAuNCwgZWFzZTogdGhpcy5vcHRpb25zLmVhc2VPdXR9KTtcbiAgICAgIC8vIHRoaXMuYW4uZW5kLnJlc3RhcnQoKTtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKHRoaXMuYW4pO1xuICAgICAgdGhpcy5hbiA9IGFuaW1lKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5lbGVtZW50LFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgICAgZWFzaW5nOiAnZWFzZU91dEJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucGF1c2UoKTsgLy8gbGV0IGFjdGl2ZUluc3RhbmNlcyA9IGFuaW1lLnJ1bm5pbmc7XG4gICAgICAvLyBsZXQgaW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZihhbmltYXRpb24pO1xuICAgICAgLy8gYWN0aXZlSW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ01hZ25ldCcsXG4gIG9wdGlvbnM6IHtcbiAgICBzY2FsZTogMS4yLFxuICAgIGVhc2VPdXQ6ICdiYWNrLm91dCgzKSdcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogVHlwZUFuaW1hdGlvbiBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJzdGFydFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vIFByZXBhcmUgZWxlbWVudHNcbiAgICAgIC8vIFdyYXAgZXZlcnkgbGV0dGVyIGluIGEgc3BhblxuICAgICAgLy8gdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuZWxlbWVudC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFMvZywgXCI8c3BhbiBjbGFzcz0nbGV0dGVyJz4kJjwvc3Bhbj5cIik7XG5cbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU1xcV10vZywgXCI8c3BhbiBjbGFzcz0nbGV0dGVyJz4kJjwvc3Bhbj5cIikucmVwbGFjZSgvPiA8L2csIFwiPiZuYnNwOzxcIik7XG4gICAgICBnc2FwLnNldCh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxldHRlcicpLCB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdGFydCgpJyk7XG4gICAgICBnc2FwLmZyb21Ubyh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxldHRlcicpLCB7XG4gICAgICAgIHNjYWxlOiAyXG4gICAgICB9LCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBkZWxheTogdGhpcy5vcHRpb25zLmRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogMC4yLFxuICAgICAgICBzdGFnZ2VyOiAxIC8gKHRoaXMub3B0aW9ucy5zcGVlZCAvIDIpLFxuICAgICAgICBlYXNlOiAnYmFjay5vdXQoMyknXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAndHlwZScsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnYXV0bycsXG4gICAgc3BlZWQ6IDEwMCxcbiAgICBkZWxheTogLjVcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogUGFydGljbGVzIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgLy8gRWZmZWN0IGNlbnRlclxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNlbnRlclwiLCB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIFRFTVA6IFVzZSBGdXNpb25IZWxwZXIgaW5zdGVhZFxuICAvLyBURU1QOiBVc2UgRnVzaW9uSGVscGVyIGluc3RlYWRcblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiYXBwZW5kSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRIdG1sKHRhcmdldCwgbWFya3VwKSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBtYXJrdXApO1xuICAgICAgcmV0dXJuIHRhcmdldC5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmFwcGVuZEh0bWwoZG9jdW1lbnQuYm9keSwgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHdpZHRoPVxcXCI4MlxcXCIgaGVpZ2h0PVxcXCIxMjlcXFwiIHZpZXdCb3g9XFxcIjAgMCA4MiAxMjlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lXFxcIj5cXG4gICAgICA8Y2lyY2xlIGlkPVxcXCJ0cGxDaXJjbGVcXFwiIGN4PVxcXCI5LjVcXFwiIGN5PVxcXCI5LjVcXFwiIHI9XFxcIjkuNVxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjZmZmXFxcIiBzdHJva2Utd2lkdGg9XFxcIjNcXFwiLz5cXG4gICAgICA8cGF0aCBpZD1cXFwidHBsVHJpYW5nbGVcXFwiIGQ9XFxcIk05LjUsMCwxOSwxN0gwWlxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjZmZmXFxcIiBzdHJva2Utd2lkdGg9XFxcIjNcXFwiLz5cXG4gICAgICA8cmVjdCBpZD1cXFwidHBsUmVjdFxcXCIgd2lkdGg9XFxcIjE5XFxcIiBoZWlnaHQ9XFxcIjE5XFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiNmZmZcXFwiIHN0cm9rZS13aWR0aD1cXFwiM1xcXCIvPlxcbiAgICA8L3N2Zz5cIik7IC8vIEdhdGhlciB0ZW1wbGF0ZXNcblxuICAgICAgdGhpcy50ZW1wbGF0ZXMgPSBbe1xuICAgICAgICBub2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHBsQ2lyY2xlJylcbiAgICAgIH0sIHtcbiAgICAgICAgbm9kZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RwbFRyaWFuZ2xlJylcbiAgICAgIH0sIHtcbiAgICAgICAgbm9kZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RwbFJlY3QnKVxuICAgICAgfV07IC8vIENhY2hlIHdpZHRoL2hlaWdodFxuXG4gICAgICB0aGlzLnRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciByZWN0ID0gaXRlbS5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpdGVtLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgaXRlbS5oZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAndXBkYXRlKCknKTsgLy8gbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgLy8gdGhpcy5jZW50ZXIgPSB7XG4gICAgICAvLyAgIGxlZnQ6IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUubGVmdCkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlLndpZHRoKS8yLFxuICAgICAgLy8gICB0b3A6IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUudG9wKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuaGVpZ2h0KS8yIFxuICAgICAgLy8gfTtcbiAgICAgIC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3VwZGF0ZSgpIGNlbnRlcjonLCB0aGlzLmNlbnRlcik7XG5cbiAgICAgIGZ1bmN0aW9uIGdldExvY2FsQm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIHZhciBhID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBiID0gZWwucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiBhLmxlZnQgLSBiLmxlZnQsXG4gICAgICAgICAgdG9wOiBhLnRvcCAtIGIudG9wLFxuICAgICAgICAgIHdpZHRoOiBhLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogYS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY3QgPSBnZXRMb2NhbEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsZW1lbnQpO1xuICAgICAgdGhpcy5jZW50ZXIgPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgucm91bmQocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIpLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQocmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0YXJ0KCknKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB2YXIgc3ZnID0gdGhpcy5hcHBlbmRIdG1sKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMVxcXCIgdmlld0JveD1cXFwiMCAwIDEgMVxcXCIgc3R5bGU9XFxcInBvaW50ZXItZXZlbnRzOiBub25lOyBwb3NpdGlvbjogYWJzb2x1dGU7IG92ZXJmbG93OiB2aXNpYmxlO1xcXCI+PC9zdmc+XCIpO1xuICAgICAgc3ZnLnN0eWxlLmxlZnQgPSB0aGlzLmNlbnRlci5sZWZ0ICsgJ3B4JztcbiAgICAgIHN2Zy5zdHlsZS50b3AgPSB0aGlzLmNlbnRlci50b3AgKyAncHgnOyAvLyBHZW5lcmF0ZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICB2YXIgdHBsID0gdGhpcy50ZW1wbGF0ZXNbTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiB0aGlzLnRlbXBsYXRlcy5sZW5ndGgpIC0gMV07XG4gICAgICAgIHZhciBub2RlID0gdHBsLm5vZGUuY2xvbmVOb2RlKCk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpZCcsICdyYW5kb20tJyArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKSk7XG4gICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIG5vZGUuc3R5bGUub3BhY2l0eSA9IDA7IC8vIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnKyhvcmlnaW5YLXRwbC53aWR0aC8yKSsncHgsICcrKG9yaWdpblktdHBsLmhlaWdodC8yKSsncHgpJztcblxuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTEwcHgsIC0xMHB4KSc7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChub2RlKTsgLy9nc2FwLnRvKG5vZGUsIHtkdXJhdGlvbjogMC4yKmksIG9wYWNpdHk6IDEsIHk6ICctPTgwJywgcm90YXRpb246IDM2MCwgdHJhbnNmb3JtT3JpZ2luOiBcIjUwJSA1MCVcIn0pO1xuXG4gICAgICAgIHZhciB0bCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICAgIGRlbGF5OiAwLjA1ICogaVxuICAgICAgICB9KTsgLy8gdGwudGltZVNjYWxlKDAuMSk7XG5cbiAgICAgICAgdmFyIHggPSBpICUgMiA/IC00MCAqIChNYXRoLnJhbmRvbSgpICogMiAqIHRoaXMub3B0aW9ucy5wb3dlcikgOiA0MCAqIChNYXRoLnJhbmRvbSgpICogMiAqIHRoaXMub3B0aW9ucy5wb3dlcik7XG4gICAgICAgIHZhciB5ID0gLTMwICogKGkgLyAyICsgMSkgKiB0aGlzLm9wdGlvbnMucG93ZXI7XG4gICAgICAgIHRsLnRvKG5vZGUsIHtcbiAgICAgICAgICBkdXJhdGlvbjogMS40LFxuICAgICAgICAgIGVhc2U6IFwicG93ZXIzLm91dFwiLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICByb3RhdGlvbjogMTMwLFxuICAgICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbnMuc2NhbGUsXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjUwJSA1MCVcIlxuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGwudG8obm9kZSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjIsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGwudG8obm9kZSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCBcIi09XCIuY29uY2F0KDAuMyAqIHRoaXMub3B0aW9ucy5kZWNheSkpO1xuICAgICAgICB0bC5ldmVudENhbGxiYWNrKFwib25Db21wbGV0ZVwiLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICBpZiAocGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW25vZGVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnUGFydGljbGVzJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgc2NhbGU6IDIsXG4gICAgcG93ZXI6IDIsXG4gICAgZGVjYXk6IDNcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogU3ByaXRlc2hlZXQgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0bFwiLCB2b2lkIDApO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnb3B0aW9uczonLCB0aGlzLm9wdGlvbnMpOyAvLyBQcmVwYXJlXG4gICAgICAvLyNCVUc6IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGlzIGFsd2F5cyBub24tc2NhbGVkIGluIGdsb2JhbCBzcGFjZVxuICAgICAgLy8gbGV0IGJvdW5kcyA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vICEodGhpcy5vcHRpb25zLndpZHRoKSAmJiAodGhpcy5vcHRpb25zLndpZHRoID0gYm91bmRzLndpZHRoKTsgXG4gICAgICAvLyAhKHRoaXMub3B0aW9ucy5oZWlnaHQpICYmICh0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodCk7XG4gICAgICAvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgc2VlbXMgdG8gd29yayBiZXR0ZXIgd2l0aCBzY2FsaW5nXG5cbiAgICAgICF0aGlzLm9wdGlvbnMud2lkdGggJiYgKHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCk7XG4gICAgICAhdGhpcy5vcHRpb25zLmhlaWdodCAmJiAodGhpcy5vcHRpb25zLmhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQpOyAvLyAvLyBTZXQgYmFja2dyb3VuZCBpbWFnZVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zcmMsIFwiKVwiKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBcIjAgMFwiO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRTaXplID0gXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLndpZHRoICogdGhpcy5vcHRpb25zLnN0ZXBzLCBcInB4XCIpO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcIm5vLXJlcGVhdFwiO1xuICAgICAgdGhpcy50bCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgIHJlcGVhdDogdGhpcy5vcHRpb25zLmxvb3AgPyAtMSA6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy50bC5hZGQoZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvblg6IFwiLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMud2lkdGggKiAodGhpcy5vcHRpb25zLnN0ZXBzIC0gMSksIFwicHhcIiksXG4gICAgICAgIGVhc2U6IFwic3RlcHMoXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zdGVwcyAtIDEsIFwiKVwiKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMudGwucGxheSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgdGhpcy50bC5yZXZlcnNlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ1Nwcml0ZXNoZWV0JyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgbG9vcDogZmFsc2UsXG4gICAgZHVyYXRpb246IDUwMCxcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgIHN0ZXBzOiB1bmRlZmluZWRcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogSnVtcCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImluaXRpYWxcIiwgdm9pZCAwKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcInN0YXJ0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdGlhbCA9IHtcbiAgICAgICAgeTogZ3NhcC5nZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnQsICd5JylcbiAgICAgIH07XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICd0aGlzLmluaXRpYWwnLCB0aGlzLmluaXRpYWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0YXJ0KCknKTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHk6IHRoaXMuaW5pdGlhbC55IC0gMjAsXG4gICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgIGVhc2U6ICdwb3dlci5vdXQoNCknXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHk6IHRoaXMuaW5pdGlhbC55LFxuICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICBkZWxheTogMC41LFxuICAgICAgICBlYXNlOiAnYm91bmNlLm91dCgyMCknXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnanVtcCcsXG4gIG9wdGlvbnM6IHt9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBIYW5kQ3Vyc29yIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZWxlbWVudHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVFbGVtZW50cygpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnaGFuZC1jdXJzb3InLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2F1dG8nXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IERlYnVnZ2VyIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdcXG5cXG4nKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TG9jYWxCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgdmFyIGEgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGIgPSBlbC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IGEubGVmdCAtIGIubGVmdCxcbiAgICAgICAgICB0b3A6IGEudG9wIC0gYi50b3AsXG4gICAgICAgICAgd2lkdGg6IGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBhLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSAvLyBDbGllbnQgUmVjdFxuXG5cbiAgICAgIHZhciBjbGllbnRSZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc29sZS5sb2coJ2NsaWVudFJlY3Q6JywgY2xpZW50UmVjdCk7XG4gICAgICB2YXIgcGFyZW50Q2xpZW50UmVjdCA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc29sZS5sb2coJ3BhcmVudENsaWVudFJlY3Q6JywgcGFyZW50Q2xpZW50UmVjdCk7XG4gICAgICBjb25zb2xlLmxvZygnbG9jYWwgcmVjdDonLCBnZXRMb2NhbEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsZW1lbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ0RlYnVnZ2VyJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdhdXRvJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBHbGl0Y2hDYW52YXMgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vLS0tXG4gICAgICAvLyBJbnNwaXJlZCBieSBodHRwczovL2NvZGVwZW4uaW8vQmx1bW1lZC9wZW4vbENqaXU/ZWRpdG9ycz0wMDEwXG4gICAgICBjb25zb2xlLmxvZyhMT0csICdvcHRpb25zOicsIHRoaXMub3B0aW9ucyk7IC8vIEdldCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLCBmYWxsaW5nIGJhY2sgdG8gMS5cblxuICAgICAgdmFyIGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7IC8vIFByZXBhcmUgZWxlbWVudHNcblxuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDsgLy8gbGV0IGJvdW5kcyA9IHRoaXMub3JpZ2luYWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAvLyBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMub3JpZ2luYWwpO1xuICAgICAgLy8gUmVwbGFjZSBlbGVtZW50IC93IGNhbnZhc1xuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMub3JpZ2luYWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5lbGVtZW50LCB0aGlzLm9yaWdpbmFsKTtcbiAgICAgIHRoaXMub3JpZ2luYWwuc3R5bGUub3BhY2l0eSA9IC4xO1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgaW1nID0gbmV3IEltYWdlKCksXG4gICAgICAgICAgdyxcbiAgICAgICAgICBoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBnbGl0Y2hJbnRlcnZhbCxcbiAgICAgICAgICBzY2FsZTtcbiAgICAgIGNvbnRleHQuc2NhbGUoZHByLCBkcHIpO1xuICAgICAgaW1nLnNyYyA9IHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgICB3aW5kb3cub25yZXNpemUgPSBpbml0O1xuICAgICAgfTtcblxuICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjbGVhckludGVydmFsKGdsaXRjaEludGVydmFsKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gX3RoaXMyLm9yaWdpbmFsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoX3RoaXMyLm9yaWdpbmFsKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGNvbXB1dGVkU3R5bGUuaGVpZ2h0O1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IGNvbXB1dGVkU3R5bGUubGVmdDtcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IGNvbXB1dGVkU3R5bGUudG9wO1xuICAgICAgICBjYW52YXMuc3R5bGUudHJhbnNmb3JtID0gY29tcHV0ZWRTdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHcgPSBib3VuZHMud2lkdGggKiBkcHI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoID0gYm91bmRzLmhlaWdodCAqIGRwcjtcbiAgICAgICAgc2NhbGUgPSBpbWcud2lkdGggLyB3O1xuICAgICAgICBnbGl0Y2hJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZ2xpdGNoSW1nLCByYW5kSW50KDI1MCwgMTAwMCkpO1xuICAgICAgICB9LCAzMDApO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcgKiBkcHIsIGggKiBkcHIpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdsaXRjaEltZyA9IGZ1bmN0aW9uIGdsaXRjaEltZygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5kSW50KDEsIDEzKTsgaSsrKSB7XG4gICAgICAgICAgdmFyIHggPSBNYXRoLnJhbmRvbSgpICogdyAqIGRwcjtcbiAgICAgICAgICB2YXIgeSA9IE1hdGgucmFuZG9tKCkgKiBoICogZHByO1xuICAgICAgICAgIHZhciBzcGxpY2VXaWR0aCA9IHcgKiBkcHIgLSB4O1xuICAgICAgICAgIHZhciBzcGxpY2VIZWlnaHQgPSByYW5kSW50KDUsIGggKiBkcHIgLyAzKTsgLy8gY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCAwLCB5LCBzcGxpY2VXaWR0aCwgc3BsaWNlSGVpZ2h0LCB4LCB5LCBzcGxpY2VXaWR0aCpkcHIsIHNwbGljZUhlaWdodCpkcHIpO1xuICAgICAgICAgIC8vIGNvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgc3BsaWNlV2lkdGgsIHksIHgsIHNwbGljZUhlaWdodCwgMCwgeSwgeCwgc3BsaWNlSGVpZ2h0KmRwcik7XG4gICAgICAgICAgLy8gV09SS0lOR1xuICAgICAgICAgIC8vIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMjAwLCBpbWcud2lkdGgsIDEwMCwgMCwgMjAwL3NjYWxlLCB3LCAxMDAvc2NhbGUpO1xuXG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAyMDAsIGltZy53aWR0aCwgMTAwLCAwLCAyMDAgLyBzY2FsZSwgdywgMTAwIC8gc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmFuZEludCA9IGZ1bmN0aW9uIHJhbmRJbnQoYSwgYikge1xuICAgICAgICByZXR1cm4gfn4oTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdnbGl0Y2gtY2FudmFzJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdob3ZlcidcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogR2xpdGNoRWFzZWwgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNyY1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNhbnZhc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YWdlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwid2lkdGhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkcHJcIiwgIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID8gMSA6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAyIDogMSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2VnbWVudHNcIiwgW10pO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIFNhdmUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgIHRoaXMub3JpZ2luYWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICB0aGlzLnNyYyA9IHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdzcmMnKTsgLy8gQ3JlYXRlIGNhbnZhc1xuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdpZCcpICYmIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgdGhpcy5zdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZSh0aGlzLmNhbnZhcyk7XG4gICAgICB0aGlzLm9yaWdpbmFsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2FudmFzLCB0aGlzLm9yaWdpbmFsLm5leHRTaWJsaW5nKTtcbiAgICAgIHRoaXMub3JpZ2luYWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLm9yaWdpbmFsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMub3JpZ2luYWwpO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjb21wdXRlZFN0eWxlLmhlaWdodDtcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gY29tcHV0ZWRTdHlsZS5sZWZ0O1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IGNvbXB1dGVkU3R5bGUudG9wO1xuICAgICAgY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IGNvbXB1dGVkU3R5bGUudHJhbnNmb3JtOyAvLyBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgdGhpcy53aWR0aCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUud2lkdGgpICogdGhpcy5kcHI7XG4gICAgICB0aGlzLmhlaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuaGVpZ2h0KSAqIHRoaXMuZHByOyAvLyBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGggKiB0aGlzLmRwcjtcbiAgICAgIC8vIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodCAqIHRoaXMuZHByO1xuICAgICAgLy8gY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUodGhpcy5kcHIsIHRoaXMuZHByKTtcblxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5kcHI7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMuZHByO1xuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUodGhpcy5kcHIsIHRoaXMuZHByKTtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY2FudmFzOyAvLyB0aGlzLm9yaWdpbmFsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5vcmlnaW5hbCk7XG4gICAgICAvLyB0aGlzLm9yaWdpbmFsLnJlbW92ZSgpO1xuXG4gICAgICB0aGlzLm9yaWdpbmFsLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTsgLy8gQ3JlYXRlIHNlZ21lbnRzXG5cbiAgICAgIHZhciBzZWVkSW5kZXggPSAwLFxuICAgICAgICAgIHRvcCA9IDA7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBzZWVkID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuc2VlZFtzZWVkSW5kZXhdICogdGhpcy5vcHRpb25zLmZhY3Rvcik7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBjcmVhdGVqcy5CaXRtYXAodGhpcy5zcmMpO1xuICAgICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI0ZGRkZGRlwiKS5kcmF3UmVjdCgwLCB0b3AsIHRoaXMud2lkdGgsIHNlZWQpO1xuICAgICAgICBpbWFnZS5tYXNrID0gc2hhcGU7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaW1hZ2UpO1xuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goaW1hZ2UpOyAvLyBFbmRcblxuICAgICAgICBpZiAodG9wID49IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuaGVpZ2h0KSAqIHRoaXMuZHByKSBicmVhazsgLy8gSXRlcmF0ZSBcblxuICAgICAgICB0b3AgKz0gc2VlZDtcbiAgICAgICAgc2VlZEluZGV4ID0gc2VlZEluZGV4ID49IHRoaXMub3B0aW9ucy5zZWVkLmxlbmd0aCAtIDEgPyAwIDogKytzZWVkSW5kZXg7XG4gICAgICB9IC8vIFRpbWVsaW5lXG5cblxuICAgICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICByZXBlYXQ6IHRoaXMub3B0aW9ucy5yZXBlYXQsXG4gICAgICAgIHJlcGVhdERlbGF5OiB0aGlzLm9wdGlvbnMucmVwZWF0RGVsYXkgLyAxMDAwLFxuICAgICAgICB5b3lvOiB0aGlzLm9wdGlvbnMueW95byxcbiAgICAgICAgb25VcGRhdGU6IHRoaXMuc3RhZ2UudXBkYXRlLmJpbmQodGhpcy5zdGFnZSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50LCBpbmRleCkge1xuICAgICAgICBfdGhpczIudGltZWxpbmUuZnJvbShzZWdtZW50LCB7XG4gICAgICAgICAgeDogKE1hdGgucmFuZG9tKCkgLSAuNSkgKiAyMCAqIF90aGlzMi5vcHRpb25zLnBvd2VyLFxuICAgICAgICAgIGFscGhhOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgZWFzZTogX3RoaXMyLm9wdGlvbnMuZWFzZWluZ1xuICAgICAgICB9LCBcIlwiLmNvbmNhdChpbmRleCAqIF90aGlzMi5vcHRpb25zLnN0YWdnZXIgLyAxMDAwKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZWxpbmUudGltZVNjYWxlKHRoaXMudGltZWxpbmUuZHVyYXRpb24oKSAvICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyAxMDAwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy50aW1lbGluZS5wbGF5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lLnJldmVyc2UoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnZ2xpdGNoLWVhc2VsJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdob3ZlcicsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgZGVsYXk6IDAsXG4gICAgcmVwZWF0OiAwLFxuICAgIHJlcGVhdERlbGF5OiAxMDAwLFxuICAgIHlveW86IHRydWUsXG4gICAgc2VlZDogWzEsIDYsIDMsIDEsIDMsIDgsIDIsIDEsIDksIDQsIDcsIDFdLFxuICAgIGZhY3RvcjogMTAsXG4gICAgcG93ZXI6IDgwLFxuICAgIHN0YWdnZXI6IDEwLFxuICAgIGVhc2luZzogJ3Bvd2VyNC5pbk91dCcgLy8gYmFjay5vdXQoMyksXG5cbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogR2xpdGNoQXBwZWFyIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBfdGhpcy5vcmlnaW5hbDtcbiAgICBfdGhpcy5jb21wdXRlZFN0eWxlO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsgLy8gc3VwZXIuc3RhcnQoKTtcblxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCB0aGlzLm9wdGlvbnMpOyAvLyBQcmVwYXJlIGVsZW1lbnRzXG5cbiAgICAgIHRoaXMub3JpZ2luYWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHRoaXMuY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMub3JpZ2luYWwpOyAvLyBXcmFwIGV2ZXJ5dGhpbmcgaW4gZGl2XG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbjtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IGNvbXB1dGVkU3R5bGUud2lkdGg7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5oZWlnaHQ7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gY29tcHV0ZWRTdHlsZS50b3A7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IGNvbXB1dGVkU3R5bGUubGVmdDsgLy8gdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjQkFEQTU1JztcblxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcsIHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcpKTtcbiAgICAgIHRoaXMub3JpZ2luYWwucmVtb3ZlQXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQsIHRoaXMub3JpZ2luYWwpO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMub3JpZ2luYWwpOyAvLyBXcmFwIG9yaWdpbmFsIGluIGRpdiAoZm9yIG1hc2tpbmcgZXRjLilcblxuICAgICAgdmFyIGxheWVyV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsYXllcldyYXBwZXIsIHRoaXMub3JpZ2luYWwpO1xuICAgICAgbGF5ZXJXcmFwcGVyLmFwcGVuZENoaWxkKHRoaXMub3JpZ2luYWwpO1xuICAgICAgdGhpcy5vcmlnaW5hbCA9IGxheWVyV3JhcHBlcjsgLy8gR2VuZXJhdGUgRWxlbWVudHNcblxuICAgICAgdGhpcy5nZW5lcmF0ZUVsZW1lbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgdmFyIGdsaXRjaGVkID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5nbGl0Y2hlZCcpO1xuICAgICAgZ3NhcC5zZXQodGhpcy5vcmlnaW5hbCwge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICAgIGdzYXAuc2V0KGdsaXRjaGVkLCB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pO1xuICAgICAgdmFyIHRsID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwXG4gICAgICB9KTtcbiAgICAgIGdsaXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIC8vIGxldCBwb3dlciA9IDIwO1xuICAgICAgICB2YXIgcG93ZXIgPSAzMDtcbiAgICAgICAgdmFyIGxheWVyVGwgPSBnc2FwLnRpbWVsaW5lKCk7XG4gICAgICAgIGxheWVyVGwudG8oaXRlbSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjA0LFxuICAgICAgICAgIG9wYWNpdHk6IDAuMixcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlclxuICAgICAgICB9LCBcIis9MC4wMlwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMC40LFxuICAgICAgICAgIHg6IDBcbiAgICAgICAgfSwgXCIrPTAuMDJcIik7XG4gICAgICAgIGxheWVyVGwudG8oaXRlbSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjA0LFxuICAgICAgICAgIG9wYWNpdHk6IDAuNixcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlclxuICAgICAgICB9LCBcIis9MFwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgIHg6IDBcbiAgICAgICAgfSwgXCIrPTAuMDJcIik7XG4gICAgICAgIGxheWVyVGwudG8oe30sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4wMlxuICAgICAgICB9KTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlclxuICAgICAgICB9LCBcIis9MFwiKTsgLy8gbGF5ZXJUbC50byhpdGVtLCB7ZHVyYXRpb246IDAuMDQsIG9wYWNpdHk6IDEsIHg6IDB9LCBgKz0wLjAyYCk7XG4gICAgICAgIC8vIGxheWVyVGwudG8oaXRlbSwge2R1cmF0aW9uOiAwLjA0LCBvcGFjaXR5OiAxLCB4OiAoTWF0aC5yYW5kb20oKS0wLjUpKnBvd2VyfSwgYCs9MC4wMmApO1xuXG4gICAgICAgIGxheWVyVGwudG8oaXRlbSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjA0LFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgeDogMFxuICAgICAgICB9LCBcIis9MC4wMlwiKTtcbiAgICAgICAgdGwuYWRkKGxheWVyVGwsIGluZGV4IC8gMTApOyAvLyB0bC5hZGQoIGxheWVyVGwsIDAuNSApO1xuICAgICAgfSk7IC8vIHRsLnRvKHRoaXMub3JpZ2luYWwsIHtkdXJhdGlvbjogMC4yLCBvcGFjaXR5OiAxfSwgLjUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbGVtZW50c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUVsZW1lbnRzKCkge1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb21wdXRlZFN0eWxlLndpZHRoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLm9yaWdpbmFsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY2xvbmUuY2xhc3NMaXN0LmFkZCgnZ2xpdGNoZWQnKTtcbiAgICAgICAgY2xvbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjbG9uZS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChpICogNjAsIFwicHhcIik7XG4gICAgICAgIGNsb25lLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBjbG9uZS5zdHlsZS53aWR0aCA9IHRoaXMuY29tcHV0ZWRTdHlsZS53aWR0aDsgLy8gY2xvbmUuc3R5bGUuaGVpZ2h0ID0gJzMwcHgnO1xuXG4gICAgICAgIGNsb25lLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KDUgKyBNYXRoLnJhbmRvbSgpICogODAsIFwicHhcIik7IC8vIGNsb25lLnN0eWxlLmZpbHRlciA9ICdncmF5c2NhbGUoMTAlKSc7XG4gICAgICAgIC8vIGNsb25lLnN0eWxlLmZpbHRlciA9IGBicmlnaHRuZXNzKDEuMDQpYDtcblxuICAgICAgICBjbG9uZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB2YXIgY2hpbGQgPSBjbG9uZS5maXJzdENoaWxkO1xuICAgICAgICBjaGlsZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNoaWxkLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGkgKiAtNjAsIFwicHhcIik7XG4gICAgICAgIGNoaWxkLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnR2xpdGNoQXBwZWFyJyxcbiAgb3B0aW9uczoge1xuICAgIGRlbGF5OiAwXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IEdsaXRjaEJhc2UgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzLm9yaWdpbmFsO1xuICAgIF90aGlzLmNvbXB1dGVkU3R5bGU7XG4gICAgX3RoaXMuc2VnbWVudHMgPSBbXTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vIFByZXBhcmUgZWxlbWVudHNcblxuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gdGhpcy5jb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5vcmlnaW5hbCk7IC8vIFdyYXAgZXZlcnl0aGluZyBpbiBkaXZcblxuICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBjb21wdXRlZFN0eWxlLmhlaWdodDsgLy8gSWdub3JlIHRyYW5zZm9ybXNcblxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IGNvbXB1dGVkU3R5bGUudG9wO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBjb21wdXRlZFN0eWxlLmxlZnQ7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gY29tcHV0ZWRTdHlsZS50cmFuc2Zvcm07IC8vIEluY29ycG9yYXRlIHRyYW5zZm9ybXNcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdib3VuZCcsIGJvdW5kKTtcbiAgICAgIC8vIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSBib3VuZC50b3ArJ3B4JztcbiAgICAgIC8vIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gYm91bmQubGVmdCsncHgnO1xuICAgICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjQkFEQTU1JztcbiAgICAgIC8vIHRoaXMuZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcsIHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcpKTtcbiAgICAgIHRoaXMub3JpZ2luYWwucmVtb3ZlQXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQsIHRoaXMub3JpZ2luYWwpO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMub3JpZ2luYWwpOyAvLyBXcmFwIG9yaWdpbmFsIGluIGRpdiAoZm9yIG1hc2tpbmcgZXRjLilcblxuICAgICAgdmFyIGxheWVyV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbGF5ZXJXcmFwcGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB0aGlzLm9yaWdpbmFsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxheWVyV3JhcHBlciwgdGhpcy5vcmlnaW5hbCk7XG4gICAgICBsYXllcldyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5vcmlnaW5hbCk7XG4gICAgICB0aGlzLm9yaWdpbmFsID0gbGF5ZXJXcmFwcGVyOyAvLyBHZW5lcmF0ZSBFbGVtZW50c1xuXG4gICAgICB0aGlzLmdlbmVyYXRlRWxlbWVudHMoKTtcbiAgICAgIGNvbnNvbGUubG9nKExPRywgJ2dlbmVyYXRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZWxlbWVudHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVFbGVtZW50cygpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY29tcHV0ZWRTdHlsZS53aWR0aCk7XG4gICAgICB2YXIgc2VlZEluZGV4ID0gMCxcbiAgICAgICAgICB0b3AgPSAwLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgc2VlZCA9IHRoaXMub3B0aW9ucy5zZWVkW3NlZWRJbmRleF0gKiB0aGlzLm9wdGlvbnMuZmFjdG9yO1xuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLm9yaWdpbmFsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY2xvbmUuY2xhc3NMaXN0LmFkZCgnZ2xpdGNoZWQnKTtcbiAgICAgICAgY2xvbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjbG9uZS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgICAgIGNsb25lLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgY2xvbmUuc3R5bGUud2lkdGggPSB0aGlzLmNvbXB1dGVkU3R5bGUud2lkdGg7IC8vIGNsb25lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdEZWVwUGluayc7XG5cbiAgICAgICAgY2xvbmUuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoc2VlZCwgXCJweFwiKTsgLy8gY2xvbmUuc3R5bGUuZmlsdGVyID0gJ2dyYXlzY2FsZSgxMDAlKSc7XG4gICAgICAgIC8vIGNsb25lLnN0eWxlLmZpbHRlciA9IGBicmlnaHRuZXNzKDEuMDQpYDtcblxuICAgICAgICBjbG9uZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICBjbG9uZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICB2YXIgY2hpbGQgPSBjbG9uZS5maXJzdENoaWxkO1xuICAgICAgICBjaGlsZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNoaWxkLnN0eWxlLnRvcCA9IFwiLVwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgICAgIGNoaWxkLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgY2hpbGQuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgICBjaGlsZC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goY2xvbmUpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvbmUpOyAvLyBFbmRcblxuICAgICAgICBpZiAodG9wID49IHBhcnNlSW50KHRoaXMuY29tcHV0ZWRTdHlsZS5oZWlnaHQpKSBicmVhazsgLy8gSXRlcmF0ZVxuICAgICAgICAvLyB0b3AgKz0gc2VlZDtcblxuICAgICAgICB0b3AgKz0gc2VlZCAtIDE7IC8vIE5vdGU6IFdlIG5lZWQgMXB4IG92ZXJsYXBwaW5nIHRvIHByZXZlbnQgd2hpdGUgbGluZXMgd2hlbiBzY2FsaW5nIChyb3VuZGluZyBpc3N1ZSlcblxuICAgICAgICBzZWVkSW5kZXggPSBzZWVkSW5kZXggPj0gdGhpcy5vcHRpb25zLnNlZWQubGVuZ3RoIC0gMSA/IDAgOiArK3NlZWRJbmRleDtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdnbGl0Y2gtYmFzZScsXG4gIG9wdGlvbnM6IHtcbiAgICBkZWxheTogMCxcbiAgICBzZWVkOiBbMSwgNiwgMywgMSwgMywgOCwgMiwgMSwgOSwgNCwgNywgMV0sXG4gICAgZmFjdG9yOiAyMFxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgR2xpdGNoQmFzZSBmcm9tICcuL0dsaXRjaEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogR2xpdGNoSW5PdXQgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2xpdGNoQmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9HbGl0Y2hCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzLnRpbWVsaW5lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMudGltZWxpbmUgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgcGF1c2VkOiB0cnVlLFxuICAgICAgICBkZWxheTogdGhpcy5vcHRpb25zLmRlbGF5IC8gMTAwMFxuICAgICAgfSk7XG4gICAgICB0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGdzYXAuc2V0KGl0ZW0sIHtcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIC41KSAqIDIwICogX3RoaXMyLm9wdGlvbnMucG93ZXIsXG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczIudGltZWxpbmUudG8oaXRlbSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGVhc2U6ICdQb3dlcjQuaW5PdXQnLFxuICAgICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdGFydCgpJyk7XG4gICAgICB0aGlzLnRpbWVsaW5lLnBsYXkoKTsgLy8gc2V0VGltZW91dCgoKT0+e1xuICAgICAgLy8gICB0aGlzLnRpbWVsaW5lLnJldmVyc2UoKVxuICAgICAgLy8gfSwgdGhpcy5vcHRpb25zLmRlbGF5KzE5MDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnZW5kKCknKTtcbiAgICAgIHRoaXMudGltZWxpbmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oR2xpdGNoQmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnZ2xpdGNoLWluLW91dCcsXG4gIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KSwgXCJtYW5pZmVzdFwiLCBfZGVmYXVsdCkub3B0aW9ucywge1xuICAgIHRyaWdnZXI6ICdhdXRvJyxcbiAgICBkZWxheTogMCxcbiAgICBzZWVkOiBbMSwgNiwgMywgMSwgMywgOCwgMiwgMSwgOSwgNCwgNywgMV0sXG4gICAgZmFjdG9yOiAyMCxcbiAgICBwb3dlcjogNDBcbiAgfSlcbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IFJlbW92ZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdvcHRpb25zOicsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAncmVtb3ZlJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdhdXRvJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBGYWRlIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoe3BhdXNlZDogdHJ1ZX0pO1xuXG4gICAgICBnc2FwLnNldCh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDAsXG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnZW5kKCknKTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnZmFkZScsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnYXV0bycsXG4gICAgZGVsYXk6IDEwMFxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBQYW5ab29tIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjb25zb2xlLmxvZyhMT0csICdvcHRpb25zOicsIHRoaXMub3B0aW9ucyk7IC8vIFRFTVA6IFhEIEhBQ0tcblxuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJzsgLy8gR2V0IHN0b3BzXG5cbiAgICAgIHZhciBzdG9wRWxlbWVudHMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW21vam8tZngtcGFuem9vbS1zdG9wXScpO1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RvcEVsZW1lbnRzOicsIHN0b3BFbGVtZW50cyk7IC8vIFByb2Nlc3Mgc3RvcHNcblxuICAgICAgdGhpcy5zdG9wcyA9IFtdO1xuICAgICAgc3RvcEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpdGVtLmdldEF0dHJpYnV0ZSgnbW9qby1meC1wYW56b29tLXN0b3AnKTtcbiAgICAgICAgb3B0aW9ucyA9IG1vam8uZnguRnhTY2FubmVyLmV4dHJhY3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgZGVsYXk6IDMwMDBcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzdG9wID0ge1xuICAgICAgICAgIGVsOiBpdGVtLFxuICAgICAgICAgIHNjYWxlOiBfdGhpczIuZWxlbWVudC5vZmZzZXRXaWR0aCAvIGl0ZW0ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgbGVmdDogcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoaXRlbSkudHJhbnNmb3JtLnNwbGl0KCcoJylbMV0uc3BsaXQoJywnKVs0XSksXG4gICAgICAgICAgdG9wOiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpdGVtKS50cmFuc2Zvcm0uc3BsaXQoJygnKVsxXS5zcGxpdCgnLCcpWzVdKSxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMyLnN0b3BzLnB1c2goc3RvcCk7XG5cbiAgICAgICAgaXRlbS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgaXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgfSk7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdG9wczonLCB0aGlzLnN0b3BzKTsgLy8gVGltZWxpbmVcblxuICAgICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBwYXVzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBfdGhpczIudGltZWxpbmUudG8oX3RoaXMyLmVsZW1lbnQsIHtcbiAgICAgICAgICBzY2FsZTogaXRlbS5zY2FsZSxcbiAgICAgICAgICB4OiAtaXRlbS5sZWZ0ICogaXRlbS5zY2FsZSxcbiAgICAgICAgICB5OiAtaXRlbS50b3AgKiBpdGVtLnNjYWxlLFxuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJzAgMCcsXG4gICAgICAgICAgZGVsYXk6IGluZGV4ID4gMCAmJiBfdGhpczIuc3RvcHNbaW5kZXggLSAxXS5vcHRpb25zLnN0b3AgPyAwIDogaXRlbS5vcHRpb25zLmRlbGF5IC8gMTAwMCxcbiAgICAgICAgICBkdXJhdGlvbjogMS44LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjQuaW5PdXQnLFxuICAgICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vcHRpb25zLnN0b3AgJiYgX3RoaXMyLnRpbWVsaW5lLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnRpbWVsaW5lLnBhdXNlKCk7XG5cbiAgICAgICAgICBfdGhpczIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi50aW1lbGluZS5wbGF5KCk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMudGltZWxpbmUucGxheSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdwYW56b29tJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdhdXRvJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgTmFub0V2ZW50cyBmcm9tICcuLi8uLi8uLi9saWJzL25hbm9ldmVudHMnO1xudmFyIExPRyA9ICdbIFBsdWdpbkJhc2UgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9OYW5vRXZlbnRzKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX05hbm9FdmVudHMpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KHNjZW5lLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIF90aGlzLnBsYXllciA9IHNjZW5lLnBsYXllcjtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5tYW5pZmVzdC5vcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShOYW5vRXZlbnRzKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBFeHBlcmltZW50YWwgUGx1Z2luXG5pbXBvcnQgUGx1Z2luQmFzZSBmcm9tICcuLi9QbHVnaW5CYXNlJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi8uLi9Db25zdCc7XG52YXIgTE9HID0gJ1sgUGx1Z2luIDogVmlzdWFsRGVidWdnZXIgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luQmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9QbHVnaW5CYXNlKTtcblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIG51bGwsIFt7XG4gICAga2V5OiBcIm1hbmlmZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmlmZXN0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICd2aXN1YWxEZWJ1Z2dlcicsXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMubWFuaWZlc3QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5tYW5pZmVzdCgpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJyk7XG4gICAgICB0aGlzLnNjZW5lLm9uKENvbnN0LlNDRU5FX1BSRV9SRUFEWSwgdGhpcy5vbl9zY2VuZV9wcmVSZWFkeS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuc2NlbmUub24oQ29uc3QuU0NFTkVfUkVBRFksIHRoaXMub25fc2NlbmVfcmVhZHkuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX3ByZVJlYWR5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zY2VuZV9wcmVSZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY2VuZV9wcmVSZWFkeSgpIHt9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfcmVhZHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX3JlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX3JlYWR5KCkge1xuICAgICAgdmFyIGNsb25lID0gdGhpcy5zY2VuZS5jb250ZW50LmNsb25lTm9kZShmYWxzZSk7XG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5zY2VuZS5jb250ZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XG4gICAgICBjbG9uZS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJnYmEoMCwwLDAsLjIpJztcbiAgICAgIGNsb25lLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICAgIGNsb25lLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB0aGlzLnNjZW5lLmNvbnRlbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShQbHVnaW5CYXNlKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBFeHBlcmltZW50YWwgUGx1Z2luXG5pbXBvcnQgUGx1Z2luQmFzZSBmcm9tICcuLi9QbHVnaW5CYXNlJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi8uLi9Db25zdCc7XG52YXIgTE9HID0gJ1sgUGx1Z2luIDogUGFub3JhbWEgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW5CYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX1BsdWdpbkJhc2UpO1xuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgbnVsbCwgW3tcbiAgICBrZXk6IFwibWFuaWZlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuaWZlc3QoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogJ3Bhbm9yYW1hJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNwZWVkOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBfdGhpcy5tYW5pZmVzdCA9IF90aGlzLmNvbnN0cnVjdG9yLm1hbmlmZXN0KCk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX3RoaXMubW91c2VYO1xuICAgIF90aGlzLmxhc3RTY3JvbGxUbyA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknKTtcbiAgICAgIHRoaXMuc2NlbmUub24oQ29uc3QuU0NFTkVfUFJFX1JFQURZLCB0aGlzLm9uX3NjZW5lX3ByZVJlYWR5LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5zY2VuZS5vbihDb25zdC5TQ0VORV9SRUFEWSwgdGhpcy5vbl9zY2VuZV9yZWFkeS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfcHJlUmVhZHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX3ByZVJlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX3ByZVJlYWR5KCkge1xuICAgICAgLy8gUHJlcGFyZSBzY2VuZVxuICAgICAgdGhpcy5zY2VuZS5lbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9ICdzY3JvbGwnO1xuICAgICAgdGhpcy5zY2VuZS5jb250ZW50LnN0eWxlLm92ZXJmbG93ID0gJ3Vuc2V0JzsgLy8gLy8gVHdlYWsgY29udGVudCBjb250YWluZXIgdG8gZ2V0IHJlYWwgd2lkdGhcbiAgICAgIC8vIC8vIHNjZW5lLmNvbnRlbnQuc3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAvLyBzY2VuZS5jb250ZW50LnN0eWxlLnJpZ2h0ID0gJ3Vuc2V0JztcbiAgICAgIC8vIC8vIFByZXZlbnQgaGlzdG9yeSBiYWNrIHdoZW4gc2Nyb2xsaW5nIHRvIGxlZnQgb24gdmlld3BvcnRcbiAgICAgIC8vIC8vICNUT0RPOiBOb3QgcHJldmVudGluZyBpbiBFZGdlXG4gICAgICAvLyBzY2VuZS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vICAgaWYgKGV2dC5jdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQgPD0gMCAmJiBldnQuZGVsdGFYIDwgMCkgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gfSwge3Bhc3NpdmU6IGZhbHNlfSk7XG4gICAgICAvLyAjVE9ETzogREVDSURFIE9OIFRIUk9UVExFXG5cbiAgICAgIHRoaXMuc2NlbmUuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb2pvLkZ1c2lvbkhlbHBlci50aHJvdHRsZSh0aGlzLm9uX3NjZW5lX21vdXNlTW92ZS5iaW5kKHRoaXMpLCA1MCkpOyAvLyAyMGZwc1xuXG4gICAgICB0aGlzLnNjZW5lLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uX3NjZW5lX2NsaWNrLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvbl9zY2VuZV9yZWFkeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2NlbmVfcmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fc2NlbmVfcmVhZHkoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdvbl9zY2VuZV9yZWFkeSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX21vdXNlTW92ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2NlbmVfbW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX21vdXNlTW92ZShldnQpIHtcbiAgICAgIHRoaXMubW91c2VYID0gZXZ0LmNsaWVudFggLSB0aGlzLnNjZW5lLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfY2xpY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX2NsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX2NsaWNrKGV2dCkge1xuICAgICAgLy8gQmFpbCBpZiBtb3VzZSBpcyBvbiBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuICAgICAgaWYgKGV2dC50YXJnZXQuaGFzQXR0cmlidXRlKCdtb2pvLWludGVyYWN0aXZlJykpIHJldHVybjsgLy8gQmFpbCBpZiBhbHJlYWR5IG1vdmluZy9zY3JvbGxpbmdcblxuICAgICAgaWYgKGdzYXAuaXNUd2VlbmluZyh0aGlzLnNjZW5lLmVsZW1lbnQpKSByZXR1cm47XG4gICAgICB2YXIgc2NlbmUgPSB0aGlzLnNjZW5lOyAvLyBEZXRlcm1pbmUgZGlyZWN0aW9uXG5cbiAgICAgIHZhciBtaW5TY3JvbGxUbyA9IDA7XG4gICAgICB2YXIgbWF4U2Nyb2xsVG8gPSBNYXRoLnJvdW5kKHNjZW5lLmNvbnRlbnQuc2Nyb2xsV2lkdGggKiBzY2VuZS5zY2FsZSAtIHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgdmFyIGRpciA9IHRoaXMubW91c2VYIC0gc2NlbmUuZWxlbWVudC5jbGllbnRXaWR0aCAvIDIgPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgIGRpciA9IHNjZW5lLmVsZW1lbnQuc2Nyb2xsTGVmdCA8PSBtaW5TY3JvbGxUbyA/ICdyaWdodCcgOiBkaXI7XG4gICAgICBkaXIgPSBzY2VuZS5lbGVtZW50LnNjcm9sbExlZnQgPj0gbWF4U2Nyb2xsVG8gPyAnbGVmdCcgOiBkaXI7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdkaXI6JywgZGlyKTsgLy8tLS1cbiAgICAgIC8vIHN0ZXAgPSBzY2VuZSB3aWR0aFxuICAgICAgLy8gdmFyIGN1cnJlbnRJbmRleCA9IE1hdGgucm91bmQoc2NlbmUuZWxlbWVudC5zY3JvbGxMZWZ0LyhzY2VuZS5kYXRhLndpZHRoICogc2NlbmUuc2NhbGUpKTtcbiAgICAgIC8vIHZhciBzY3JvbGxUbyA9ICgoZGlyPT0nbGVmdCcpID8gY3VycmVudEluZGV4LTEgOiBjdXJyZW50SW5kZXgrMSkgKiAoc2NlbmUuZGF0YS53aWR0aCAqIHNjZW5lLnNjYWxlKTtcbiAgICAgIC8vIHNjcm9sbFRvID0gKHNjcm9sbFRvIDw9IG1pblNjcm9sbFRvKSA/ICcwJyA6IHNjcm9sbFRvO1xuICAgICAgLy8gc2Nyb2xsVG8gPSAoc2Nyb2xsVG8gPiBtYXhTY3JvbGxUbykgPyBtYXhTY3JvbGxUbyA6IHNjcm9sbFRvO1xuICAgICAgLy8tLS1cbiAgICAgIC8vIHN0ZXAgPSBjdXN0b20gc3RvcHNcblxuICAgICAgdmFyIHN0b3BzID0gdGhpcy5vcHRpb25zLnN0b3BzO1xuICAgICAgaWYgKCFzdG9wcykgY29uc29sZS5lcnJvcihMT0csICdtaXNzaW5nIG9wdGlvbnMgXCJzdG9wc1wiJyk7XG4gICAgICBzdG9wcyA9IHN0b3BzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogc2NlbmUuc2NhbGUpO1xuICAgICAgfSk7XG4gICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pO1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RvcHMnLCBzdG9wcyk7XG4gICAgICB2YXIgY3VycmVudFNjcm9sbENlbnRlciA9IE1hdGgucm91bmQoc2NlbmUuZWxlbWVudC5zY3JvbGxMZWZ0ICsgc2NlbmUuZWxlbWVudC5jbGllbnRXaWR0aCAvIDIgLSAoc2NlbmUuZWxlbWVudC5jbGllbnRXaWR0aCAtIHNjZW5lLmNvbnRlbnQuY2xpZW50V2lkdGggKiBzY2VuZS5zY2FsZSkgLyAyKTsgLy8gREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnY3VycmVudFNjcm9sbENlbnRlcicsIGN1cnJlbnRTY3JvbGxDZW50ZXIpO1xuXG4gICAgICB2YXIgc2Nyb2xsVG87XG4gICAgICB2YXIgc3RvcCA9IDA7XG5cbiAgICAgIGlmIChkaXIgPT0gJ2xlZnQnKSB7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBzbWFsbGVyIHN0b3AgKHJlbGF0aXZlIHRvIGN1cnJlbnQgc2Nyb2xsIGNlbnRlcilcbiAgICAgICAgdmFyIHN0b3BzUmV2ZXJzZSA9IHN0b3BzLnNsaWNlKDApLnJldmVyc2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzUmV2ZXJzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gc3RvcHNSZXZlcnNlW2ldO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gPCBjdXJyZW50U2Nyb2xsQ2VudGVyKSB7XG4gICAgICAgICAgICBzdG9wID0gaXRlbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluZCBuZXh0IGhpZ2hlciBzdG9wIChyZWxhdGl2ZSB0byBjdXJyZW50IHNjcm9sbCBjZW50ZXIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHN0b3BzW2ldO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gPiBjdXJyZW50U2Nyb2xsQ2VudGVyICsgMSkge1xuICAgICAgICAgICAgc3RvcCA9IGl0ZW07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2FsY3VsYXRlIHNjcm9sbCBuZXcgcG9zaXRpb25cblxuXG4gICAgICBzY3JvbGxUbyA9IE1hdGguZmxvb3Ioc3RvcCAtIHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLyAyICsgKHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLSBzY2VuZS5jb250ZW50LmNsaWVudFdpZHRoICogc2NlbmUuc2NhbGUpIC8gMik7XG4gICAgICBzY3JvbGxUbyA9IHNjcm9sbFRvIDw9IG1pblNjcm9sbFRvID8gJzAnIDogc2Nyb2xsVG87XG4gICAgICBzY3JvbGxUbyA9IHNjcm9sbFRvID4gbWF4U2Nyb2xsVG8gPyBtYXhTY3JvbGxUbyA6IHNjcm9sbFRvOyAvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzY3JvbGxUbycsIHNjcm9sbFRvKTtcbiAgICAgIC8vIER1cmF0aW9uIHJlbGF0aXZlIHRvIGRpc3RhbmNlXG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IE1hdGguYWJzKHRoaXMubGFzdFNjcm9sbFRvIC0gc2Nyb2xsVG8pIC8gMTIwMCAvIHRoaXMub3B0aW9ucy5zcGVlZDtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gPCAuMiA/IC4yIDogZHVyYXRpb247IC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3NwZWVkJywgdGhpcy5vcHRpb25zLnNwZWVkKTtcbiAgICAgIC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2R1cmF0aW9uJywgZHVyYXRpb24pO1xuICAgICAgLy8gUmVtZW1iZXJcblxuICAgICAgdGhpcy5sYXN0U2Nyb2xsVG8gPSBzY3JvbGxUbzsgLy8gVHdlZW4gICAgXG5cbiAgICAgIGdzYXAuaXNUd2VlbmluZyhzY2VuZS5lbGVtZW50KSAmJiBnc2FwLmtpbGxUd2VlbnNPZihzY2VuZS5lbGVtZW50KTtcbiAgICAgIGdzYXAudG8oc2NlbmUuZWxlbWVudCwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGVhc2U6ICdwb3dlcjQuaW5PdXQnLFxuICAgICAgICBzY3JvbGxMZWZ0OiBzY3JvbGxUbyxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAvLyB1cGRhdGVDdXJzb3JEaXIoKTtcbiAgICAgICAgICAvLyBQcm9wYWdhdGUgY3VzdG9tX3NsaWRlX2FjdGl2ZVxuICAgICAgICAgIHNjZW5lLmVtaXQoJ2N1c3RvbV9zbGlkZV9hY3RpdmUnLCB7XG4gICAgICAgICAgICBpbmRleDogc3RvcHMuaW5kZXhPZihzdG9wKSxcbiAgICAgICAgICAgIHNjcm9sbFRvOiBzY3JvbGxUb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KFBsdWdpbkJhc2UpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC50aHJvdHRsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCBNb2pvIGZyb20gJy4vbW9qby9jb3JlL01vam8nOyAvLyBpbXBvcnQge0Z1c2lvbkhlbHBlcn0gZnJvbSAnLi9tb2pvL2NvcmUvRnVzaW9uSGVscGVyJztcblxuaW1wb3J0IEZ4U2Nhbm5lciBmcm9tICcuL21vam8vZngvRnhTY2FubmVyJztcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi9tb2pvL2Z4L0Z4QmFzZSc7IC8vIEVmZmVjdHNcblxuaW1wb3J0IEdsaXRjaCBmcm9tICcuL21vam8vZngvY29yZS9HbGl0Y2gnO1xuaW1wb3J0IE1hZ25ldCBmcm9tICcuL21vam8vZngvY29yZS9NYWduZXQnO1xuaW1wb3J0IEhpZGUgZnJvbSAnLi9tb2pvL2Z4L2NvcmUvSGlkZSc7XG5pbXBvcnQgQW5pbWVNYWduZXQgZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9hbmltZS9NYWduZXQnO1xuaW1wb3J0IFR5cGVBbmltYXRpb24gZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9UeXBlQW5pbWF0aW9uJztcbmltcG9ydCBQYXJ0aWNsZXMgZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9QYXJ0aWNsZXMnO1xuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gJy4vbW9qby9meC9leHBlcmltZW50YWwvU3ByaXRlc2hlZXQnO1xuaW1wb3J0IEp1bXAgZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9KdW1wJztcbmltcG9ydCBIYW5kQ3Vyc29yIGZyb20gJy4vbW9qby9meC9leHBlcmltZW50YWwvSGFuZEN1cnNvcic7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9EZWJ1Z2dlcic7XG5pbXBvcnQgR2xpdGNoQ2FudmFzIGZyb20gJy4vbW9qby9meC9leHBlcmltZW50YWwvR2xpdGNoQ2FudmFzJztcbmltcG9ydCBHbGl0Y2hFYXNlbCBmcm9tICcuL21vam8vZngvZXhwZXJpbWVudGFsL0dsaXRjaEVhc2VsJztcbmltcG9ydCBHbGl0Y2hBcHBlYXIgZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hBcHBlYXInO1xuaW1wb3J0IEdsaXRjaEluT3V0IGZyb20gJy4vbW9qby9meC9leHBlcmltZW50YWwvR2xpdGNoSW5PdXQnO1xuaW1wb3J0IFJlbW92ZSBmcm9tICcuL21vam8vZngvZXhwZXJpbWVudGFsL1JlbW92ZSc7XG5pbXBvcnQgRmFkZSBmcm9tICcuL21vam8vZngvZXhwZXJpbWVudGFsL0ZhZGUnO1xuaW1wb3J0IFBhblpvb20gZnJvbSAnLi9tb2pvL2Z4L2V4cGVyaW1lbnRhbC9QYW5ab29tJztcbmltcG9ydCBWaXN1YWxEZWJ1Z2dlciBmcm9tICcuL2Z1c2lvbi9wbHVnaW5zL3dpcC9WaXN1YWxEZWJ1Z2dlcic7XG5pbXBvcnQgUGFub3JhbWEgZnJvbSAnLi9mdXNpb24vcGx1Z2lucy93aXAvUGFub3JhbWEnO1xuaW1wb3J0ICcuLi9zdHlsZS9mdXNpb24uc2Nzcyc7XG5cbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcblxuY29uc29sZS5sb2coJ1sgTW9qbyBdJywgJ1ZFUlNJT04nLCB2ZXJzaW9uKTsgLy8gR3NhcCBEZWZhdWx0c1xuXG5nc2FwLmRlZmF1bHRzKHtcbiAgZWFzZTogXCJwb3dlcjIuaW5PdXRcIixcbiAgZHVyYXRpb246IDAuNVxufSk7XG5nc2FwLmNvbmZpZyh7XG4gIGZvcmNlM0Q6IHRydWVcbn0pOyAvLyBHbG9iYWwgTW9qbyBpbnN0YW5jZVxuXG53aW5kb3cubW9qbyA9IG5ldyBNb2pvKCk7IC8vIFVzZSBNb2pvIGluc3RhbmNlIGFzIG5hbWVzcGFjZSBmb3IgYWxsIGNsYXNzZXNcblxuT2JqZWN0LmFzc2lnbih3aW5kb3cubW9qbywge1xuICAvLyBGdXNpb25IZWxwZXIsIC8vIE1PVkVEIFRPIEZVU0lPTlxuICAvLyAjVE9ETzogRGVjaWRlIGJldHdlZW4gRnVzaW9uSGVscGVyLnRocm90dGxlIGFuZCBoZWxwZXIudGhyb3R0bGUgKGxvZGFzaClcbiAgaGVscGVyOiB7XG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgIGRlYm91bmNlOiBkZWJvdW5jZVxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgUGFub3JhbWE6IFBhbm9yYW1hLFxuICAgIFZpc3VhbERlYnVnZ2VyOiBWaXN1YWxEZWJ1Z2dlclxuICB9LFxuICBmeDoge1xuICAgIEZ4QmFzZTogRnhCYXNlLFxuICAgIERlYnVnZ2VyOiBEZWJ1Z2dlcixcbiAgICBGeFNjYW5uZXI6IEZ4U2Nhbm5lcixcbiAgICBHbGl0Y2g6IEdsaXRjaCxcbiAgICBNYWduZXQ6IE1hZ25ldCxcbiAgICBIaWRlOiBIaWRlLFxuICAgIFBhcnRpY2xlczogUGFydGljbGVzLFxuICAgIEhhbmRDdXJzb3I6IEhhbmRDdXJzb3IsXG4gICAgSnVtcDogSnVtcCxcbiAgICBHbGl0Y2hBcHBlYXI6IEdsaXRjaEFwcGVhcixcbiAgICBHbGl0Y2hJbk91dDogR2xpdGNoSW5PdXQsXG4gICAgR2xpdGNoQ2FudmFzOiBHbGl0Y2hDYW52YXMsXG4gICAgR2xpdGNoRWFzZWw6IEdsaXRjaEVhc2VsLFxuICAgIFR5cGVBbmltYXRpb246IFR5cGVBbmltYXRpb24sXG4gICAgU3ByaXRlc2hlZXQ6IFNwcml0ZXNoZWV0LFxuICAgIFJlbW92ZTogUmVtb3ZlLFxuICAgIEZhZGU6IEZhZGUsXG4gICAgUGFuWm9vbTogUGFuWm9vbSxcbiAgICBleDoge1xuICAgICAgYW5pbWU6IHtcbiAgICAgICAgTWFnbmV0OiBBbmltZU1hZ25ldFxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n')}]);